{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"The Fern Programming Language Fern is a natively compiled, highly versatile language intended to bring together metaprogramming, performance, and ease-of-use to a happy medium. Examples exist but are small tidbits meant to facilitate parser testing, the language is not functional. For more information, see the following pages: FNC Compiler Grammar Lexical Metaprogramming Model","title":"Home"},{"location":"#the-fern-programming-language","text":"Fern is a natively compiled, highly versatile language intended to bring together metaprogramming, performance, and ease-of-use to a happy medium. Examples exist but are small tidbits meant to facilitate parser testing, the language is not functional.","title":"The Fern Programming Language"},{"location":"#for-more-information-see-the-following-pages","text":"FNC Compiler Grammar Lexical Metaprogramming Model","title":"For more information, see the following pages:"},{"location":"LICENSE/","text":"GNU Free Documentation License Version 1.3, 3 November 2008 Copyright (C) 2000, 2001, 2002, 2007, 2008 Free Software Foundation, Inc. https://fsf.org/ Everyone is permitted to copy and distribute verbatim copies of this license document, but changing it is not allowed. 0. PREAMBLE The purpose of this License is to make a manual, textbook, or other functional and useful document \"free\" in the sense of freedom: to assure everyone the effective freedom to copy and redistribute it, with or without modifying it, either commercially or noncommercially. Secondarily, this License preserves for the author and publisher a way to get credit for their work, while not being considered responsible for modifications made by others. This License is a kind of \"copyleft\", which means that derivative works of the document must themselves be free in the same sense. It complements the GNU General Public License, which is a copyleft license designed for free software. We have designed this License in order to use it for manuals for free software, because free software needs free documentation: a free program should come with manuals providing the same freedoms that the software does. But this License is not limited to software manuals; it can be used for any textual work, regardless of subject matter or whether it is published as a printed book. We recommend this License principally for works whose purpose is instruction or reference. 1. APPLICABILITY AND DEFINITIONS This License applies to any manual or other work, in any medium, that contains a notice placed by the copyright holder saying it can be distributed under the terms of this License. Such a notice grants a world-wide, royalty-free license, unlimited in duration, to use that work under the conditions stated herein. The \"Document\", below, refers to any such manual or work. Any member of the public is a licensee, and is addressed as \"you\". You accept the license if you copy, modify or distribute the work in a way requiring permission under copyright law. A \"Modified Version\" of the Document means any work containing the Document or a portion of it, either copied verbatim, or with modifications and/or translated into another language. A \"Secondary Section\" is a named appendix or a front-matter section of the Document that deals exclusively with the relationship of the publishers or authors of the Document to the Document's overall subject (or to related matters) and contains nothing that could fall directly within that overall subject. (Thus, if the Document is in part a textbook of mathematics, a Secondary Section may not explain any mathematics.) The relationship could be a matter of historical connection with the subject or with related matters, or of legal, commercial, philosophical, ethical or political position regarding them. The \"Invariant Sections\" are certain Secondary Sections whose titles are designated, as being those of Invariant Sections, in the notice that says that the Document is released under this License. If a section does not fit the above definition of Secondary then it is not allowed to be designated as Invariant. The Document may contain zero Invariant Sections. If the Document does not identify any Invariant Sections then there are none. The \"Cover Texts\" are certain short passages of text that are listed, as Front-Cover Texts or Back-Cover Texts, in the notice that says that the Document is released under this License. A Front-Cover Text may be at most 5 words, and a Back-Cover Text may be at most 25 words. A \"Transparent\" copy of the Document means a machine-readable copy, represented in a format whose specification is available to the general public, that is suitable for revising the document straightforwardly with generic text editors or (for images composed of pixels) generic paint programs or (for drawings) some widely available drawing editor, and that is suitable for input to text formatters or for automatic translation to a variety of formats suitable for input to text formatters. A copy made in an otherwise Transparent file format whose markup, or absence of markup, has been arranged to thwart or discourage subsequent modification by readers is not Transparent. An image format is not Transparent if used for any substantial amount of text. A copy that is not \"Transparent\" is called \"Opaque\". Examples of suitable formats for Transparent copies include plain ASCII without markup, Texinfo input format, LaTeX input format, SGML or XML using a publicly available DTD, and standard-conforming simple HTML, PostScript or PDF designed for human modification. Examples of transparent image formats include PNG, XCF and JPG. Opaque formats include proprietary formats that can be read and edited only by proprietary word processors, SGML or XML for which the DTD and/or processing tools are not generally available, and the machine-generated HTML, PostScript or PDF produced by some word processors for output purposes only. The \"Title Page\" means, for a printed book, the title page itself, plus such following pages as are needed to hold, legibly, the material this License requires to appear in the title page. For works in formats which do not have any title page as such, \"Title Page\" means the text near the most prominent appearance of the work's title, preceding the beginning of the body of the text. The \"publisher\" means any person or entity that distributes copies of the Document to the public. A section \"Entitled XYZ\" means a named subunit of the Document whose title either is precisely XYZ or contains XYZ in parentheses following text that translates XYZ in another language. (Here XYZ stands for a specific section name mentioned below, such as \"Acknowledgements\", \"Dedications\", \"Endorsements\", or \"History\".) To \"Preserve the Title\" of such a section when you modify the Document means that it remains a section \"Entitled XYZ\" according to this definition. The Document may include Warranty Disclaimers next to the notice which states that this License applies to the Document. These Warranty Disclaimers are considered to be included by reference in this License, but only as regards disclaiming warranties: any other implication that these Warranty Disclaimers may have is void and has no effect on the meaning of this License. 2. VERBATIM COPYING You may copy and distribute the Document in any medium, either commercially or noncommercially, provided that this License, the copyright notices, and the license notice saying this License applies to the Document are reproduced in all copies, and that you add no other conditions whatsoever to those of this License. You may not use technical measures to obstruct or control the reading or further copying of the copies you make or distribute. However, you may accept compensation in exchange for copies. If you distribute a large enough number of copies you must also follow the conditions in section 3. You may also lend copies, under the same conditions stated above, and you may publicly display copies. 3. COPYING IN QUANTITY If you publish printed copies (or copies in media that commonly have printed covers) of the Document, numbering more than 100, and the Document's license notice requires Cover Texts, you must enclose the copies in covers that carry, clearly and legibly, all these Cover Texts: Front-Cover Texts on the front cover, and Back-Cover Texts on the back cover. Both covers must also clearly and legibly identify you as the publisher of these copies. The front cover must present the full title with all words of the title equally prominent and visible. You may add other material on the covers in addition. Copying with changes limited to the covers, as long as they preserve the title of the Document and satisfy these conditions, can be treated as verbatim copying in other respects. If the required texts for either cover are too voluminous to fit legibly, you should put the first ones listed (as many as fit reasonably) on the actual cover, and continue the rest onto adjacent pages. If you publish or distribute Opaque copies of the Document numbering more than 100, you must either include a machine-readable Transparent copy along with each Opaque copy, or state in or with each Opaque copy a computer-network location from which the general network-using public has access to download using public-standard network protocols a complete Transparent copy of the Document, free of added material. If you use the latter option, you must take reasonably prudent steps, when you begin distribution of Opaque copies in quantity, to ensure that this Transparent copy will remain thus accessible at the stated location until at least one year after the last time you distribute an Opaque copy (directly or through your agents or retailers) of that edition to the public. It is requested, but not required, that you contact the authors of the Document well before redistributing any large number of copies, to give them a chance to provide you with an updated version of the Document. 4. MODIFICATIONS You may copy and distribute a Modified Version of the Document under the conditions of sections 2 and 3 above, provided that you release the Modified Version under precisely this License, with the Modified Version filling the role of the Document, thus licensing distribution and modification of the Modified Version to whoever possesses a copy of it. In addition, you must do these things in the Modified Version: A. Use in the Title Page (and on the covers, if any) a title distinct from that of the Document, and from those of previous versions (which should, if there were any, be listed in the History section of the Document). You may use the same title as a previous version if the original publisher of that version gives permission. B. List on the Title Page, as authors, one or more persons or entities responsible for authorship of the modifications in the Modified Version, together with at least five of the principal authors of the Document (all of its principal authors, if it has fewer than five), unless they release you from this requirement. C. State on the Title page the name of the publisher of the Modified Version, as the publisher. D. Preserve all the copyright notices of the Document. E. Add an appropriate copyright notice for your modifications adjacent to the other copyright notices. F. Include, immediately after the copyright notices, a license notice giving the public permission to use the Modified Version under the terms of this License, in the form shown in the Addendum below. G. Preserve in that license notice the full lists of Invariant Sections and required Cover Texts given in the Document's license notice. H. Include an unaltered copy of this License. I. Preserve the section Entitled \"History\", Preserve its Title, and add to it an item stating at least the title, year, new authors, and publisher of the Modified Version as given on the Title Page. If there is no section Entitled \"History\" in the Document, create one stating the title, year, authors, and publisher of the Document as given on its Title Page, then add an item describing the Modified Version as stated in the previous sentence. J. Preserve the network location, if any, given in the Document for public access to a Transparent copy of the Document, and likewise the network locations given in the Document for previous versions it was based on. These may be placed in the \"History\" section. You may omit a network location for a work that was published at least four years before the Document itself, or if the original publisher of the version it refers to gives permission. K. For any section Entitled \"Acknowledgements\" or \"Dedications\", Preserve the Title of the section, and preserve in the section all the substance and tone of each of the contributor acknowledgements and/or dedications given therein. L. Preserve all the Invariant Sections of the Document, unaltered in their text and in their titles. Section numbers or the equivalent are not considered part of the section titles. M. Delete any section Entitled \"Endorsements\". Such a section may not be included in the Modified Version. N. Do not retitle any existing section to be Entitled \"Endorsements\" or to conflict in title with any Invariant Section. O. Preserve any Warranty Disclaimers. If the Modified Version includes new front-matter sections or appendices that qualify as Secondary Sections and contain no material copied from the Document, you may at your option designate some or all of these sections as invariant. To do this, add their titles to the list of Invariant Sections in the Modified Version's license notice. These titles must be distinct from any other section titles. You may add a section Entitled \"Endorsements\", provided it contains nothing but endorsements of your Modified Version by various parties\u2014for example, statements of peer review or that the text has been approved by an organization as the authoritative definition of a standard. You may add a passage of up to five words as a Front-Cover Text, and a passage of up to 25 words as a Back-Cover Text, to the end of the list of Cover Texts in the Modified Version. Only one passage of Front-Cover Text and one of Back-Cover Text may be added by (or through arrangements made by) any one entity. If the Document already includes a cover text for the same cover, previously added by you or by arrangement made by the same entity you are acting on behalf of, you may not add another; but you may replace the old one, on explicit permission from the previous publisher that added the old one. The author(s) and publisher(s) of the Document do not by this License give permission to use their names for publicity for or to assert or imply endorsement of any Modified Version. 5. COMBINING DOCUMENTS You may combine the Document with other documents released under this License, under the terms defined in section 4 above for modified versions, provided that you include in the combination all of the Invariant Sections of all of the original documents, unmodified, and list them all as Invariant Sections of your combined work in its license notice, and that you preserve all their Warranty Disclaimers. The combined work need only contain one copy of this License, and multiple identical Invariant Sections may be replaced with a single copy. If there are multiple Invariant Sections with the same name but different contents, make the title of each such section unique by adding at the end of it, in parentheses, the name of the original author or publisher of that section if known, or else a unique number. Make the same adjustment to the section titles in the list of Invariant Sections in the license notice of the combined work. In the combination, you must combine any sections Entitled \"History\" in the various original documents, forming one section Entitled \"History\"; likewise combine any sections Entitled \"Acknowledgements\", and any sections Entitled \"Dedications\". You must delete all sections Entitled \"Endorsements\". 6. COLLECTIONS OF DOCUMENTS You may make a collection consisting of the Document and other documents released under this License, and replace the individual copies of this License in the various documents with a single copy that is included in the collection, provided that you follow the rules of this License for verbatim copying of each of the documents in all other respects. You may extract a single document from such a collection, and distribute it individually under this License, provided you insert a copy of this License into the extracted document, and follow this License in all other respects regarding verbatim copying of that document. 7. AGGREGATION WITH INDEPENDENT WORKS A compilation of the Document or its derivatives with other separate and independent documents or works, in or on a volume of a storage or distribution medium, is called an \"aggregate\" if the copyright resulting from the compilation is not used to limit the legal rights of the compilation's users beyond what the individual works permit. When the Document is included in an aggregate, this License does not apply to the other works in the aggregate which are not themselves derivative works of the Document. If the Cover Text requirement of section 3 is applicable to these copies of the Document, then if the Document is less than one half of the entire aggregate, the Document's Cover Texts may be placed on covers that bracket the Document within the aggregate, or the electronic equivalent of covers if the Document is in electronic form. Otherwise they must appear on printed covers that bracket the whole aggregate. 8. TRANSLATION Translation is considered a kind of modification, so you may distribute translations of the Document under the terms of section 4. Replacing Invariant Sections with translations requires special permission from their copyright holders, but you may include translations of some or all Invariant Sections in addition to the original versions of these Invariant Sections. You may include a translation of this License, and all the license notices in the Document, and any Warranty Disclaimers, provided that you also include the original English version of this License and the original versions of those notices and disclaimers. In case of a disagreement between the translation and the original version of this License or a notice or disclaimer, the original version will prevail. If a section in the Document is Entitled \"Acknowledgements\", \"Dedications\", or \"History\", the requirement (section 4) to Preserve its Title (section 1) will typically require changing the actual title. 9. TERMINATION You may not copy, modify, sublicense, or distribute the Document except as expressly provided under this License. Any attempt otherwise to copy, modify, sublicense, or distribute it is void, and will automatically terminate your rights under this License. However, if you cease all violation of this License, then your license from a particular copyright holder is reinstated (a) provisionally, unless and until the copyright holder explicitly and finally terminates your license, and (b) permanently, if the copyright holder fails to notify you of the violation by some reasonable means prior to 60 days after the cessation. Moreover, your license from a particular copyright holder is reinstated permanently if the copyright holder notifies you of the violation by some reasonable means, this is the first time you have received notice of violation of this License (for any work) from that copyright holder, and you cure the violation prior to 30 days after your receipt of the notice. Termination of your rights under this section does not terminate the licenses of parties who have received copies or rights from you under this License. If your rights have been terminated and not permanently reinstated, receipt of a copy of some or all of the same material does not give you any rights to use it. 10. FUTURE REVISIONS OF THIS LICENSE The Free Software Foundation may publish new, revised versions of the GNU Free Documentation License from time to time. Such new versions will be similar in spirit to the present version, but may differ in detail to address new problems or concerns. See https://www.gnu.org/licenses/ . Each version of the License is given a distinguishing version number. If the Document specifies that a particular numbered version of this License \"or any later version\" applies to it, you have the option of following the terms and conditions either of that specified version or of any later version that has been published (not as a draft) by the Free Software Foundation. If the Document does not specify a version number of this License, you may choose any version ever published (not as a draft) by the Free Software Foundation. If the Document specifies that a proxy can decide which future versions of this License can be used, that proxy's public statement of acceptance of a version permanently authorizes you to choose that version for the Document. 11. RELICENSING \"Massive Multiauthor Collaboration Site\" (or \"MMC Site\") means any World Wide Web server that publishes copyrightable works and also provides prominent facilities for anybody to edit those works. A public wiki that anybody can edit is an example of such a server. A \"Massive Multiauthor Collaboration\" (or \"MMC\") contained in the site means any set of copyrightable works thus published on the MMC site. \"CC-BY-SA\" means the Creative Commons Attribution-Share Alike 3.0 license published by Creative Commons Corporation, a not-for-profit corporation with a principal place of business in San Francisco, California, as well as future copyleft versions of that license published by that same organization. \"Incorporate\" means to publish or republish a Document, in whole or in part, as part of another Document. An MMC is \"eligible for relicensing\" if it is licensed under this License, and if all works that were first published under this License somewhere other than this MMC, and subsequently incorporated in whole or in part into the MMC, (1) had no cover texts or invariant sections, and (2) were thus incorporated prior to November 1, 2008. The operator of an MMC Site may republish an MMC contained in the site under CC-BY-SA on the same site at any time before August 1, 2009, provided the MMC is eligible for relicensing. ADDENDUM: How to use this License for your documents To use this License in a document you have written, include a copy of the License in the document and put the following copyright and license notices just after the title page: Copyright (C) YEAR YOUR NAME. Permission is granted to copy, distribute and/or modify this document under the terms of the GNU Free Documentation License, Version 1.3 or any later version published by the Free Software Foundation; with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts. A copy of the license is included in the section entitled \"GNU Free Documentation License\". If you have Invariant Sections, Front-Cover Texts and Back-Cover Texts, replace the \"with \u2026 Texts.\" line with this: with the Invariant Sections being LIST THEIR TITLES, with the Front-Cover Texts being LIST, and with the Back-Cover Texts being LIST. If you have Invariant Sections without Cover Texts, or some other combination of the three, merge those two alternatives to suit the situation. If your document contains nontrivial examples of program code, we recommend releasing these examples in parallel under your choice of free software license, such as the GNU General Public License, to permit their use in free software.","title":"Copyleft"},{"location":"LICENSE/#gnu-free-documentation-license","text":"Version 1.3, 3 November 2008 Copyright (C) 2000, 2001, 2002, 2007, 2008 Free Software Foundation, Inc. https://fsf.org/ Everyone is permitted to copy and distribute verbatim copies of this license document, but changing it is not allowed.","title":"GNU Free Documentation License"},{"location":"LICENSE/#0-preamble","text":"The purpose of this License is to make a manual, textbook, or other functional and useful document \"free\" in the sense of freedom: to assure everyone the effective freedom to copy and redistribute it, with or without modifying it, either commercially or noncommercially. Secondarily, this License preserves for the author and publisher a way to get credit for their work, while not being considered responsible for modifications made by others. This License is a kind of \"copyleft\", which means that derivative works of the document must themselves be free in the same sense. It complements the GNU General Public License, which is a copyleft license designed for free software. We have designed this License in order to use it for manuals for free software, because free software needs free documentation: a free program should come with manuals providing the same freedoms that the software does. But this License is not limited to software manuals; it can be used for any textual work, regardless of subject matter or whether it is published as a printed book. We recommend this License principally for works whose purpose is instruction or reference.","title":"0. PREAMBLE"},{"location":"LICENSE/#1-applicability-and-definitions","text":"This License applies to any manual or other work, in any medium, that contains a notice placed by the copyright holder saying it can be distributed under the terms of this License. Such a notice grants a world-wide, royalty-free license, unlimited in duration, to use that work under the conditions stated herein. The \"Document\", below, refers to any such manual or work. Any member of the public is a licensee, and is addressed as \"you\". You accept the license if you copy, modify or distribute the work in a way requiring permission under copyright law. A \"Modified Version\" of the Document means any work containing the Document or a portion of it, either copied verbatim, or with modifications and/or translated into another language. A \"Secondary Section\" is a named appendix or a front-matter section of the Document that deals exclusively with the relationship of the publishers or authors of the Document to the Document's overall subject (or to related matters) and contains nothing that could fall directly within that overall subject. (Thus, if the Document is in part a textbook of mathematics, a Secondary Section may not explain any mathematics.) The relationship could be a matter of historical connection with the subject or with related matters, or of legal, commercial, philosophical, ethical or political position regarding them. The \"Invariant Sections\" are certain Secondary Sections whose titles are designated, as being those of Invariant Sections, in the notice that says that the Document is released under this License. If a section does not fit the above definition of Secondary then it is not allowed to be designated as Invariant. The Document may contain zero Invariant Sections. If the Document does not identify any Invariant Sections then there are none. The \"Cover Texts\" are certain short passages of text that are listed, as Front-Cover Texts or Back-Cover Texts, in the notice that says that the Document is released under this License. A Front-Cover Text may be at most 5 words, and a Back-Cover Text may be at most 25 words. A \"Transparent\" copy of the Document means a machine-readable copy, represented in a format whose specification is available to the general public, that is suitable for revising the document straightforwardly with generic text editors or (for images composed of pixels) generic paint programs or (for drawings) some widely available drawing editor, and that is suitable for input to text formatters or for automatic translation to a variety of formats suitable for input to text formatters. A copy made in an otherwise Transparent file format whose markup, or absence of markup, has been arranged to thwart or discourage subsequent modification by readers is not Transparent. An image format is not Transparent if used for any substantial amount of text. A copy that is not \"Transparent\" is called \"Opaque\". Examples of suitable formats for Transparent copies include plain ASCII without markup, Texinfo input format, LaTeX input format, SGML or XML using a publicly available DTD, and standard-conforming simple HTML, PostScript or PDF designed for human modification. Examples of transparent image formats include PNG, XCF and JPG. Opaque formats include proprietary formats that can be read and edited only by proprietary word processors, SGML or XML for which the DTD and/or processing tools are not generally available, and the machine-generated HTML, PostScript or PDF produced by some word processors for output purposes only. The \"Title Page\" means, for a printed book, the title page itself, plus such following pages as are needed to hold, legibly, the material this License requires to appear in the title page. For works in formats which do not have any title page as such, \"Title Page\" means the text near the most prominent appearance of the work's title, preceding the beginning of the body of the text. The \"publisher\" means any person or entity that distributes copies of the Document to the public. A section \"Entitled XYZ\" means a named subunit of the Document whose title either is precisely XYZ or contains XYZ in parentheses following text that translates XYZ in another language. (Here XYZ stands for a specific section name mentioned below, such as \"Acknowledgements\", \"Dedications\", \"Endorsements\", or \"History\".) To \"Preserve the Title\" of such a section when you modify the Document means that it remains a section \"Entitled XYZ\" according to this definition. The Document may include Warranty Disclaimers next to the notice which states that this License applies to the Document. These Warranty Disclaimers are considered to be included by reference in this License, but only as regards disclaiming warranties: any other implication that these Warranty Disclaimers may have is void and has no effect on the meaning of this License.","title":"1. APPLICABILITY AND DEFINITIONS"},{"location":"LICENSE/#2-verbatim-copying","text":"You may copy and distribute the Document in any medium, either commercially or noncommercially, provided that this License, the copyright notices, and the license notice saying this License applies to the Document are reproduced in all copies, and that you add no other conditions whatsoever to those of this License. You may not use technical measures to obstruct or control the reading or further copying of the copies you make or distribute. However, you may accept compensation in exchange for copies. If you distribute a large enough number of copies you must also follow the conditions in section 3. You may also lend copies, under the same conditions stated above, and you may publicly display copies.","title":"2. VERBATIM COPYING"},{"location":"LICENSE/#3-copying-in-quantity","text":"If you publish printed copies (or copies in media that commonly have printed covers) of the Document, numbering more than 100, and the Document's license notice requires Cover Texts, you must enclose the copies in covers that carry, clearly and legibly, all these Cover Texts: Front-Cover Texts on the front cover, and Back-Cover Texts on the back cover. Both covers must also clearly and legibly identify you as the publisher of these copies. The front cover must present the full title with all words of the title equally prominent and visible. You may add other material on the covers in addition. Copying with changes limited to the covers, as long as they preserve the title of the Document and satisfy these conditions, can be treated as verbatim copying in other respects. If the required texts for either cover are too voluminous to fit legibly, you should put the first ones listed (as many as fit reasonably) on the actual cover, and continue the rest onto adjacent pages. If you publish or distribute Opaque copies of the Document numbering more than 100, you must either include a machine-readable Transparent copy along with each Opaque copy, or state in or with each Opaque copy a computer-network location from which the general network-using public has access to download using public-standard network protocols a complete Transparent copy of the Document, free of added material. If you use the latter option, you must take reasonably prudent steps, when you begin distribution of Opaque copies in quantity, to ensure that this Transparent copy will remain thus accessible at the stated location until at least one year after the last time you distribute an Opaque copy (directly or through your agents or retailers) of that edition to the public. It is requested, but not required, that you contact the authors of the Document well before redistributing any large number of copies, to give them a chance to provide you with an updated version of the Document.","title":"3. COPYING IN QUANTITY"},{"location":"LICENSE/#4-modifications","text":"You may copy and distribute a Modified Version of the Document under the conditions of sections 2 and 3 above, provided that you release the Modified Version under precisely this License, with the Modified Version filling the role of the Document, thus licensing distribution and modification of the Modified Version to whoever possesses a copy of it. In addition, you must do these things in the Modified Version: A. Use in the Title Page (and on the covers, if any) a title distinct from that of the Document, and from those of previous versions (which should, if there were any, be listed in the History section of the Document). You may use the same title as a previous version if the original publisher of that version gives permission. B. List on the Title Page, as authors, one or more persons or entities responsible for authorship of the modifications in the Modified Version, together with at least five of the principal authors of the Document (all of its principal authors, if it has fewer than five), unless they release you from this requirement. C. State on the Title page the name of the publisher of the Modified Version, as the publisher. D. Preserve all the copyright notices of the Document. E. Add an appropriate copyright notice for your modifications adjacent to the other copyright notices. F. Include, immediately after the copyright notices, a license notice giving the public permission to use the Modified Version under the terms of this License, in the form shown in the Addendum below. G. Preserve in that license notice the full lists of Invariant Sections and required Cover Texts given in the Document's license notice. H. Include an unaltered copy of this License. I. Preserve the section Entitled \"History\", Preserve its Title, and add to it an item stating at least the title, year, new authors, and publisher of the Modified Version as given on the Title Page. If there is no section Entitled \"History\" in the Document, create one stating the title, year, authors, and publisher of the Document as given on its Title Page, then add an item describing the Modified Version as stated in the previous sentence. J. Preserve the network location, if any, given in the Document for public access to a Transparent copy of the Document, and likewise the network locations given in the Document for previous versions it was based on. These may be placed in the \"History\" section. You may omit a network location for a work that was published at least four years before the Document itself, or if the original publisher of the version it refers to gives permission. K. For any section Entitled \"Acknowledgements\" or \"Dedications\", Preserve the Title of the section, and preserve in the section all the substance and tone of each of the contributor acknowledgements and/or dedications given therein. L. Preserve all the Invariant Sections of the Document, unaltered in their text and in their titles. Section numbers or the equivalent are not considered part of the section titles. M. Delete any section Entitled \"Endorsements\". Such a section may not be included in the Modified Version. N. Do not retitle any existing section to be Entitled \"Endorsements\" or to conflict in title with any Invariant Section. O. Preserve any Warranty Disclaimers. If the Modified Version includes new front-matter sections or appendices that qualify as Secondary Sections and contain no material copied from the Document, you may at your option designate some or all of these sections as invariant. To do this, add their titles to the list of Invariant Sections in the Modified Version's license notice. These titles must be distinct from any other section titles. You may add a section Entitled \"Endorsements\", provided it contains nothing but endorsements of your Modified Version by various parties\u2014for example, statements of peer review or that the text has been approved by an organization as the authoritative definition of a standard. You may add a passage of up to five words as a Front-Cover Text, and a passage of up to 25 words as a Back-Cover Text, to the end of the list of Cover Texts in the Modified Version. Only one passage of Front-Cover Text and one of Back-Cover Text may be added by (or through arrangements made by) any one entity. If the Document already includes a cover text for the same cover, previously added by you or by arrangement made by the same entity you are acting on behalf of, you may not add another; but you may replace the old one, on explicit permission from the previous publisher that added the old one. The author(s) and publisher(s) of the Document do not by this License give permission to use their names for publicity for or to assert or imply endorsement of any Modified Version.","title":"4. MODIFICATIONS"},{"location":"LICENSE/#5-combining-documents","text":"You may combine the Document with other documents released under this License, under the terms defined in section 4 above for modified versions, provided that you include in the combination all of the Invariant Sections of all of the original documents, unmodified, and list them all as Invariant Sections of your combined work in its license notice, and that you preserve all their Warranty Disclaimers. The combined work need only contain one copy of this License, and multiple identical Invariant Sections may be replaced with a single copy. If there are multiple Invariant Sections with the same name but different contents, make the title of each such section unique by adding at the end of it, in parentheses, the name of the original author or publisher of that section if known, or else a unique number. Make the same adjustment to the section titles in the list of Invariant Sections in the license notice of the combined work. In the combination, you must combine any sections Entitled \"History\" in the various original documents, forming one section Entitled \"History\"; likewise combine any sections Entitled \"Acknowledgements\", and any sections Entitled \"Dedications\". You must delete all sections Entitled \"Endorsements\".","title":"5. COMBINING DOCUMENTS"},{"location":"LICENSE/#6-collections-of-documents","text":"You may make a collection consisting of the Document and other documents released under this License, and replace the individual copies of this License in the various documents with a single copy that is included in the collection, provided that you follow the rules of this License for verbatim copying of each of the documents in all other respects. You may extract a single document from such a collection, and distribute it individually under this License, provided you insert a copy of this License into the extracted document, and follow this License in all other respects regarding verbatim copying of that document.","title":"6. COLLECTIONS OF DOCUMENTS"},{"location":"LICENSE/#7-aggregation-with-independent-works","text":"A compilation of the Document or its derivatives with other separate and independent documents or works, in or on a volume of a storage or distribution medium, is called an \"aggregate\" if the copyright resulting from the compilation is not used to limit the legal rights of the compilation's users beyond what the individual works permit. When the Document is included in an aggregate, this License does not apply to the other works in the aggregate which are not themselves derivative works of the Document. If the Cover Text requirement of section 3 is applicable to these copies of the Document, then if the Document is less than one half of the entire aggregate, the Document's Cover Texts may be placed on covers that bracket the Document within the aggregate, or the electronic equivalent of covers if the Document is in electronic form. Otherwise they must appear on printed covers that bracket the whole aggregate.","title":"7. AGGREGATION WITH INDEPENDENT WORKS"},{"location":"LICENSE/#8-translation","text":"Translation is considered a kind of modification, so you may distribute translations of the Document under the terms of section 4. Replacing Invariant Sections with translations requires special permission from their copyright holders, but you may include translations of some or all Invariant Sections in addition to the original versions of these Invariant Sections. You may include a translation of this License, and all the license notices in the Document, and any Warranty Disclaimers, provided that you also include the original English version of this License and the original versions of those notices and disclaimers. In case of a disagreement between the translation and the original version of this License or a notice or disclaimer, the original version will prevail. If a section in the Document is Entitled \"Acknowledgements\", \"Dedications\", or \"History\", the requirement (section 4) to Preserve its Title (section 1) will typically require changing the actual title.","title":"8. TRANSLATION"},{"location":"LICENSE/#9-termination","text":"You may not copy, modify, sublicense, or distribute the Document except as expressly provided under this License. Any attempt otherwise to copy, modify, sublicense, or distribute it is void, and will automatically terminate your rights under this License. However, if you cease all violation of this License, then your license from a particular copyright holder is reinstated (a) provisionally, unless and until the copyright holder explicitly and finally terminates your license, and (b) permanently, if the copyright holder fails to notify you of the violation by some reasonable means prior to 60 days after the cessation. Moreover, your license from a particular copyright holder is reinstated permanently if the copyright holder notifies you of the violation by some reasonable means, this is the first time you have received notice of violation of this License (for any work) from that copyright holder, and you cure the violation prior to 30 days after your receipt of the notice. Termination of your rights under this section does not terminate the licenses of parties who have received copies or rights from you under this License. If your rights have been terminated and not permanently reinstated, receipt of a copy of some or all of the same material does not give you any rights to use it.","title":"9. TERMINATION"},{"location":"LICENSE/#10-future-revisions-of-this-license","text":"The Free Software Foundation may publish new, revised versions of the GNU Free Documentation License from time to time. Such new versions will be similar in spirit to the present version, but may differ in detail to address new problems or concerns. See https://www.gnu.org/licenses/ . Each version of the License is given a distinguishing version number. If the Document specifies that a particular numbered version of this License \"or any later version\" applies to it, you have the option of following the terms and conditions either of that specified version or of any later version that has been published (not as a draft) by the Free Software Foundation. If the Document does not specify a version number of this License, you may choose any version ever published (not as a draft) by the Free Software Foundation. If the Document specifies that a proxy can decide which future versions of this License can be used, that proxy's public statement of acceptance of a version permanently authorizes you to choose that version for the Document.","title":"10. FUTURE REVISIONS OF THIS LICENSE"},{"location":"LICENSE/#11-relicensing","text":"\"Massive Multiauthor Collaboration Site\" (or \"MMC Site\") means any World Wide Web server that publishes copyrightable works and also provides prominent facilities for anybody to edit those works. A public wiki that anybody can edit is an example of such a server. A \"Massive Multiauthor Collaboration\" (or \"MMC\") contained in the site means any set of copyrightable works thus published on the MMC site. \"CC-BY-SA\" means the Creative Commons Attribution-Share Alike 3.0 license published by Creative Commons Corporation, a not-for-profit corporation with a principal place of business in San Francisco, California, as well as future copyleft versions of that license published by that same organization. \"Incorporate\" means to publish or republish a Document, in whole or in part, as part of another Document. An MMC is \"eligible for relicensing\" if it is licensed under this License, and if all works that were first published under this License somewhere other than this MMC, and subsequently incorporated in whole or in part into the MMC, (1) had no cover texts or invariant sections, and (2) were thus incorporated prior to November 1, 2008. The operator of an MMC Site may republish an MMC contained in the site under CC-BY-SA on the same site at any time before August 1, 2009, provided the MMC is eligible for relicensing.","title":"11. RELICENSING"},{"location":"LICENSE/#addendum-how-to-use-this-license-for-your-documents","text":"To use this License in a document you have written, include a copy of the License in the document and put the following copyright and license notices just after the title page: Copyright (C) YEAR YOUR NAME. Permission is granted to copy, distribute and/or modify this document under the terms of the GNU Free Documentation License, Version 1.3 or any later version published by the Free Software Foundation; with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts. A copy of the license is included in the section entitled \"GNU Free Documentation License\". If you have Invariant Sections, Front-Cover Texts and Back-Cover Texts, replace the \"with \u2026 Texts.\" line with this: with the Invariant Sections being LIST THEIR TITLES, with the Front-Cover Texts being LIST, and with the Back-Cover Texts being LIST. If you have Invariant Sections without Cover Texts, or some other combination of the three, merge those two alternatives to suit the situation. If your document contains nontrivial examples of program code, we recommend releasing these examples in parallel under your choice of free software license, such as the GNU General Public License, to permit their use in free software.","title":"ADDENDUM: How to use this License for your documents"},{"location":"fnc/","text":"FNC Strings & Vectorization FNC uses heap-last vector-first schema for strings. Strings do not have the same priority as vector types, like a long[2] but retains second priority at all times to try to fit them into registers. If a string overflows outside of a vector, it will go onto the heap instead, where it will act as a rope which allocates ahead of itself to account for repeated reassignment at the cost of using extra memory. Vectors are not explicitly defined as types, but all static arrays that directly correspond to a vector type will act as a vector type implicitly, these are defined as the following types. Type Intel Intrinsics byte[16] __m128i ubyte[16] __m128i short[8] __m128i ushort[8] __m128i int[4] __m128i uint[4] __m128i long[2] __m128i ulong[2] __m128i float[4] __m128 double[2] __m128d byte[32] __m256i ubyte[32] __m256i short[16] __m256i ushort[16] __m256i int[8] __m256i uint[8] __m256i long[4] __m256i ulong[4] __m256i float[8] __m256 double[4] __m256d byte[64] __m512i ubyte[64] __m512i short[32] __m512i ushort[32] __m512i int[16] __m512i uint[16] __m512i long[8] __m512i ulong[8] __m512i float[16] __m512 double[8] __m512d The following intrinsics are defined for such vector types: TODO: TBD Phases The Arbore project tree is read before anything else and arbore.json is used to determine compilation information, if it exists, which is highly recommended to allow for caching of metadata which aids in compilation speeds. Lexical Analysis Source code is split up into tokens and initially parsed. Syntax Analysis Tokens are parsed to make usable input for the compiler, during this phase comptime errors for basic syntax are thrown. Function call inference is done during this phase, determining special syntax such as implicit generics instantiation, UFCS function extensions, etc. Semantic Analysis Input code is made to actually usable code, symbols are resolved, tables are set up, functions are generated, and inference is done. This may take place numerous times. Inference will be done by the compiler back-end during this phase, determining function attributes that were not implicitly declared and throwing comptime errors that were not previously caught. Evaluation & Resolution Symbols which may not be resolved without a prior step, such as executing comptime functions or otherwise mixing in code is done, if this results in a symbol being evaluated then semantic analysis will take place again to resolve whatever was done by this step. Pollution, Scoring & Initialization Function instructions are traversed to determine hierarchy of pollution, scoring variables based on frequency, and initialization of variables are added if they are not already initialized. Vector types are always maximally scored, meaning they have guaranteed priority to their registers over other non-vector types. Optimization I Instructions which may be evaluated at comptime are automatically evaluated and their results are inlined. This will result in expressions like if (true) or 1 + 2 to evaluate to no branch and 3 respectively. Inefficient operations, such as mov rax, 0 would be replaced with their more effective counterparts, like xor rax, rax and inference of intentions and implications are done for later passes. Optimization II Optimization III Optimization IV Optimization V Linear Reference Counting Variables are linearly reference counted, this is done by traversing the instructions of functions in the current hierarchy and checking when the variable is last accessed, it is collected after the last time it has been accessed or not collected if it either exits all scopes in the hierarchy or is unable to be confidently determined to be collectable. A variable would not be collected if it is used in a call to an external function with unavailable source, assigned to a global field, assigned to an external object's data, or otherwise leaves the scope in a way where it cannot be tracked; this would lead to the garbage collector handling the object rather than the reference counter. Compilation After all functions have been resolved types are set up, functions are compiled, data is inlined to the object, and the final compiled object is prepared to be linked in the next phase. Linking The compiled object is linked, producing the actual binary. Caching Comptime information that was previously evaluated in the Evaluation & Resolution stage are cached to better streamline the build process in the future. This is only done if the compilation took place in an Arbore project. Arbore Arbore is the standardized Fern build system intended to be an cross-compiler system to allow any compiler to easily cache metadata and understand your project at a glance. Structure bin\\ source\\ arbore-selections.json arbore.json bin\\ holds all recent compilations and cached metadata, namely comptime information used to speed up future builds and recent binaries. source\\ holds all source files used for compilation, this may be modified to not be used or for other folders to also contain source files using arb.json . Internal folders inside of a source folder are ignored by compilation and have no bearing on output. arbore-selections.json is reserved and not explicitly required. It is intended to eventually be used for adding library dependencies. arbore.json is the core of Arbore, all contents are reserved.","title":"FNC"},{"location":"fnc/#fnc","text":"","title":"FNC"},{"location":"fnc/#strings-vectorization","text":"FNC uses heap-last vector-first schema for strings. Strings do not have the same priority as vector types, like a long[2] but retains second priority at all times to try to fit them into registers. If a string overflows outside of a vector, it will go onto the heap instead, where it will act as a rope which allocates ahead of itself to account for repeated reassignment at the cost of using extra memory. Vectors are not explicitly defined as types, but all static arrays that directly correspond to a vector type will act as a vector type implicitly, these are defined as the following types. Type Intel Intrinsics byte[16] __m128i ubyte[16] __m128i short[8] __m128i ushort[8] __m128i int[4] __m128i uint[4] __m128i long[2] __m128i ulong[2] __m128i float[4] __m128 double[2] __m128d byte[32] __m256i ubyte[32] __m256i short[16] __m256i ushort[16] __m256i int[8] __m256i uint[8] __m256i long[4] __m256i ulong[4] __m256i float[8] __m256 double[4] __m256d byte[64] __m512i ubyte[64] __m512i short[32] __m512i ushort[32] __m512i int[16] __m512i uint[16] __m512i long[8] __m512i ulong[8] __m512i float[16] __m512 double[8] __m512d The following intrinsics are defined for such vector types: TODO: TBD","title":"Strings &amp; Vectorization"},{"location":"fnc/#phases","text":"The Arbore project tree is read before anything else and arbore.json is used to determine compilation information, if it exists, which is highly recommended to allow for caching of metadata which aids in compilation speeds. Lexical Analysis Source code is split up into tokens and initially parsed. Syntax Analysis Tokens are parsed to make usable input for the compiler, during this phase comptime errors for basic syntax are thrown. Function call inference is done during this phase, determining special syntax such as implicit generics instantiation, UFCS function extensions, etc. Semantic Analysis Input code is made to actually usable code, symbols are resolved, tables are set up, functions are generated, and inference is done. This may take place numerous times. Inference will be done by the compiler back-end during this phase, determining function attributes that were not implicitly declared and throwing comptime errors that were not previously caught. Evaluation & Resolution Symbols which may not be resolved without a prior step, such as executing comptime functions or otherwise mixing in code is done, if this results in a symbol being evaluated then semantic analysis will take place again to resolve whatever was done by this step. Pollution, Scoring & Initialization Function instructions are traversed to determine hierarchy of pollution, scoring variables based on frequency, and initialization of variables are added if they are not already initialized. Vector types are always maximally scored, meaning they have guaranteed priority to their registers over other non-vector types. Optimization I Instructions which may be evaluated at comptime are automatically evaluated and their results are inlined. This will result in expressions like if (true) or 1 + 2 to evaluate to no branch and 3 respectively. Inefficient operations, such as mov rax, 0 would be replaced with their more effective counterparts, like xor rax, rax and inference of intentions and implications are done for later passes. Optimization II Optimization III Optimization IV Optimization V Linear Reference Counting Variables are linearly reference counted, this is done by traversing the instructions of functions in the current hierarchy and checking when the variable is last accessed, it is collected after the last time it has been accessed or not collected if it either exits all scopes in the hierarchy or is unable to be confidently determined to be collectable. A variable would not be collected if it is used in a call to an external function with unavailable source, assigned to a global field, assigned to an external object's data, or otherwise leaves the scope in a way where it cannot be tracked; this would lead to the garbage collector handling the object rather than the reference counter. Compilation After all functions have been resolved types are set up, functions are compiled, data is inlined to the object, and the final compiled object is prepared to be linked in the next phase. Linking The compiled object is linked, producing the actual binary. Caching Comptime information that was previously evaluated in the Evaluation & Resolution stage are cached to better streamline the build process in the future. This is only done if the compilation took place in an Arbore project.","title":"Phases"},{"location":"fnc/#arbore","text":"Arbore is the standardized Fern build system intended to be an cross-compiler system to allow any compiler to easily cache metadata and understand your project at a glance.","title":"Arbore"},{"location":"fnc/#structure","text":"bin\\ source\\ arbore-selections.json arbore.json bin\\ holds all recent compilations and cached metadata, namely comptime information used to speed up future builds and recent binaries. source\\ holds all source files used for compilation, this may be modified to not be used or for other folders to also contain source files using arb.json . Internal folders inside of a source folder are ignored by compilation and have no bearing on output. arbore-selections.json is reserved and not explicitly required. It is intended to eventually be used for adding library dependencies. arbore.json is the core of Arbore, all contents are reserved.","title":"Structure"},{"location":"grammar/","text":"Grammar Module module name Modules are top level declarations which act like namespaces and may contain lower members inside of it. A module identifier cannot be used more than once unless the module was declared using the partial attribute. A declaration of a module appears as such module name; or partial module name; where name is the name of the module which is being declared. Import import name Import declarations are used to import modules to be used, and may be used anywhere within code, with their effects only applicable in the scope which they were declared. A whole module may be imported with import name; where name is the name of the module being imported, this may include submodules such as in import foo.bar; where the submodule bar in foo is imported, along with all of the submodules of bar . A selection may be imported with import name : foo where name is the name of the module being imported from and foo is the symbol being imported from the module, the same submodule importing rules apply as with whole module imports. A public import may be import even to other modules which import the module in which the public import was declared, this can be done like public import name where name is the name of the module being imported. module foo; public import bar; In this example importing foo would result in also importing bar . Types type is type variable is type Types and variables may be compared to a type using is to evaluate if they are of the same type, this may also be used for comparing a variable to a tagged to see what it contains. Types have a minimum size of 1 byte, but it is a comptime error to use a type with no members to declare a variable. (see Fields and Variables ) Builtins The following types are built into Fern, and may be used without any imports: Type Definition Size (b) bool Boolean, false if 0, true otherwise. 1 byte 8-bit signed integer. 1 ubyte 8-bit unsigned integer. 1 short 16-bit signed integer. 2 ushort 16-bit unsigned integer. 2 int 32-bit signed integer. 4 uint 32-bit unsigned integer. 4 long 64-bit signed integer. 8 ulong 64-bit unsigned integer. 8 float 32-bit floating point. 4 double 64-bit floating point. 8 void Represents an untype, may be pointed to but not explicitly declared as a variable. 1 nint Represents the max size signed integer available. variable nuint Represents the max size unsigned integer available. variable char 8-bit character integer. 1 wchar 16-bit character integer. 2 dchar 32-bit character integer. 4 string A string formed out of char variable (array) wstring A string formed out of wchar variable (array) dstring A string formed out of dchar variable (array) Strings are defined as dynamic arrays if their value is not known at comptime, or static arrays if their value is known at comptime (ie: string literals.) Operators Operators are a builtin part of the language used to perform certain operations. All of these may be overloaded and functionality varies, but should by default apply by normal rationality. Operator Definition \\|> Conversion pipe operator, used to pipe data to a type, member function, or field. <\\| Downcast operator, downcasts data to its superior type or dereference. > < <= >= Comparison operators, special behavior is defined for array types, which return a mask of where the comparison returned true. == != && \\|\\| , ! Equality and logical operators, with ! and != as NOT operators. [x] [..] [] Slicing and indexing operators, [x] will take the element of the given index, [..] will take the mask or slice of the given range, and [] will get an array as an explicit array type or element-wise array that can have operators performed on it. + - * / % ^^ << >> <<< ^ & \\| ~ Binary operators. ^^ performs exponentiation and ~ is used for range concatenation. -- ++ ~ - Unary postdecrement, postincrement, NOT, and NEG operators. Postdecrement and postincrement may appear as preX versions in which they are after a variable. & Unary pointer reference operator. x if y else z Ternary alternate operator. x..y Iota operator, creates a range from x to y not containing the value y . -> Symbol member operator, which is evaluated at comptime and may evaluate to an alias function operating on a symbol. $ Dollar operator, gets the length of a range, must be overloaded for custom ranges. Unlike other languages you must use the LTR operator <| to dereference. All unary operators are technically RTL, but most have been preserved as they don't have too much of an impact on code readability, * was singled out due to pointer dereferencing being a common operation and & rarely reading RTL in code. The following operators are defined as op-assign, meaning that they perform the operation followed by an assignment. It is highly recommended to use the mask assign operator instead of masking and then assigning when working with masks. Operator += -= *= /= %= ^^= ~= [..]= <<= >>= <<<= ^= &= \\|= [x]= Operator Overloading Almost all operators may be overloaded in types, this is done by specifying the n-nary of the operator followed by the operator, refer to the following list: Signature Overload nnary read(alias F = void)() . Field or variable reading, optionally takes a field symbol being read, otherwise this is being read. nnary write(alias F = void)() . Field or variable writing, optionally takes a field symbol being written, otherwise this is being written. nnary call(alias F, ARGS...)() . Function calls, taking the symbol of what function is being called. Will not overload UFCS calls! nnary \\|>(S...)() \\|> Conversion pipe, takes the sequence of symbols being piped through. nnary <\\|() <\\| Downcast or dereference. binary <=>(T)(T val) < > <= >= Comparison operators, return 0 for greater, 1 for lesser, 2 for greater or equal, or any other value for lesser or equal. binary ==(T)(T val) == != Equality operators. binary [](T)(T val) [x] Index operator. binary [..](T)(T val) [..] Slice mask operator. binary *(T)(T val) * Multiplication operator. binary /(T)(T val) / Division operator. binary +(T)(T val) + Addition operator. binary -(T)(T val) - Subtraction operator. binary %(T)(T val) % Modulus operator. binary ^^(T)(T val) ^^ Exponentiation operator. binary <<(T)(T val) << SHL operator. binary >>(T)(T val) >> SHL operator. binary <<<(T)(T val) <<< SHL sign preserved operator. binary ^(T)(T val) ^ XOR operator. binary &(T)(T val) & AND operator. binary \\|(T)(T val) \\| OR operator. binary ~(T)(T val) ~ Range concatentation operator. binary &~(T)(T val) & ~ ANDN operator, AND followed by a NOT. unary --() -- Postdecrement and predecrement operator. unary ++() ++ Postincrement and preincrement operator. unary -() - NEG operator. unary $() $ Range length operator. unary !~() ! ~ NOT operators. All operators with a respective assignment operator may have that assignment operator overloaded by appending = before the parameters in the signature, like in binary >>=(T)(T val) . Arrays type[] type[length] Fern defines 2 kinds of arrays, static arrays, dynamic arrays. Upon construction, all arrays may use the syntax T[x] to define their length. Dynamic arrays may be created out of any type using the syntax T[] and they store their length and pointer to data as fields length and ptr . Static arrays must have their length known at comptime and may be created out of any type using the syntax T[L] where L is the length of the array. Unlike dynamic arrays, static arrays do not store data by reference, and instead are value-types. However, they still retain comptime data for length and ptr gets a pointer to the data. Static arrays may not be concatenated through use of ~ , however they still must have their length initialized at first. Arrays are cumulative, meaning that you can have arrays of arrays and so on. Masks Arrays may be masked, this cannot explicitly be accessed as a type by the user, but can be created using slicing operations and converted back to ranges by way of the [] operator or assignment/conversion to an array type variable. Pointers type* Pointers are natively sized integers which point to memory, they may be created by using the reference operator & and dereferenced by using the dereference operator * . Pointers may be represented as void* , nint , nuint , or appending * to the end of a type. Pointers share operators with static arrays, meaning they may be sliced, indexed, and so on. Pointers are cumulative, meaning that you can point to pointers and so on. User-defined Types [aggregation] name Fern declares 3 different kinds of user-defined types. A type with no members has a minimum size of 1 byte, however it may also not be explicitly used to declare a variable. Types may be created anonymously, directly inlining their effects by not defining a name, this may not be done using classes as an anonymous nor in a tagged. An example of struct/class syntax is as follows: struct/class Element { int kind; short value; // Anonymous type, acting as a union. tagged { // These occupy the same memory space, with the size being the maximum size used by any type inside of it. int foo; long bar; } } An example of tagged syntax is as follows: tagged IpAddr { ubyte[4] V4; string V6; // This will be the type of the tag, which is uint. // The prime inherit will modify the type of the tag. V819; } All types may, but not must, contain member declarations, and the above are only examples. Tagged (types..) Tagged have a tag which indicates what kind of value they hold, but they will only ever hold one of their fields as a value. Tagged may be checked for their tag by doing foo is name or foo is type like in foo is V4 . Unlike all other types, tagged may inherit a builtin type as a prime inherit, which will act as the default type for all fields and also the type of the tag , by default the prime inherit will be assumed to be uint . Tagged may be implicitly created by wrapping multiple types in parenthesis, like (int, short) foo and assignment when value is one of int and short . Additionally, tagged may implicitly create from a type by accessing a member, like from IpAddr.V4 in which the default value of V4 is selected. If all members of a tagged are const , they may have a value assigned by default, tag is stripped away (but may still be accessed) and it acts exactly as an enum would in languages like D, Java, or C#. Otherwise default assignment is not allowed. If a tagged is an anonymous type it will not have a tag , and will act as a typical union type would. tagged A : ^ubyte { // This will result in the runtime having to do a lookup if converting 3 to A, because A is not entirely const. const a = 3; int b; } A foo = A.a; A bar = A.b(2); // Illegal! No explicit constructor calls because it is unknown what the tag is supposed to be! A baz = A(2); Fields in tagged act as the constructor as well as data, and tagged may not be directly constructed using the type. Tuple [types..] [values..] Tuples may be implicitly created by wrapping multiple types in braces, like [int, short] foo and assignment when value is both of int and short as an array literal. Tuples will usually be weighted above array literals when assigning with the brace syntax to a tuple, otherwise array literals will be weighted above. Functions [type] name([(parameters)]) { .. } name([arguments]) return => [variable][value] Functions are executable code with parameters which may be invoked through the syntax name([arguments]) . T foo(...) { ... } Functions that return a type other than void must have a return value. This can be done by using return , which may be used as a variable that will be returned at the end of the function, or as a return statement, which may appear as return; or return => [variable][value]; . Setting or modifying the value of return does not have any effect in a void function, but the return; statement will always lead to an early return. Parameters and Arguments Parameters [variable declaration]... Parameters appended with ... after their declaration will act as variadic, or array parameters which may take an infinite number of said declaration at the end of the list. If a function takes one parameter of an array type, it will be variadic by default, like in this example: void foo(int[2]) { // ... } foo(1, 2); foo([1, 2]); Variadics may appear only once in a signature, and must be the very last declaration, however this rule is slightly bypassed with generics where variadics may appear twice if one of the variadics is used as the type of a runtime argument, like in this example: void foo(A..., B...)(B b) { // ... } // It is impossible to set B explicitly, but this is allowed because it can be set implicitly based on the arguments passed. // A = [int, string] // B = [int, int] foo!(int, string)(1, 2); Parameters with values set after their declaration will have optional values set by default, these, like variadic parameters, must be the last parameters in the function signature. Arguments [variable][value]... parameter_name: [variable][value]... Parameters are syntactically an array of variable declarations, and are part of the signature of a declaration. Arguments are the actual values passed to something, like a function, and are either variables or values. You may declare a variable inline as an argument, like foo(int a) which would create a new variable a from the point of that call onwards. Named arguments may be used by using parameter_name: before the value being passed as an argument, where parameter_name is the name of the parameter the argument corresponds to. Delegates and Function Pointers Delegate declaration: [(parameters)] { ... } Function and delegate pointer types: type function([parameters]) type delegate([parameters]) Delegates are scope-independent variable functions which may be passed around and called, they are identical to function pointers in practice, but store context data meaning they are aware of this . You may explicitly create a delegate, but functions and function pointers will also become delegates implicitly. Lambdas [parameters] => .. Lambdas may be declared in function/property syntax or as inline lambdas such as a => return a == 1 where the parameter types are inferred and a delegate is constructed based on the lambda. Use of a lambda for a property will result in the property only having a get . // foo will always return 1. int foo() => 1; // foo is a property that will always return 1. property int foo() => 1; Properties property [type] name { [get { .. }] [set { .. }] Properties are special functions which act as fields, they must have the following declaration syntax, both a get and set are not necessary but you must have one of them. property T foo() { get { ... } set { ... } } This may be accessed in code as such T foo_value = foo or foo = new_foo_value . Constructors and Destructors this[(parameters)] { .. } ~this[(parameters)] { .. } Constructors are functions which are used to construct an instance of a type, they are to be called on a type as if the type itself were a function and must be declared with the following syntax: this(...) { ... } Constructors may be called on existing data by use of foo.ctor() in which the overload is chosen by the arguments. Destructors are functions which are used to free an instance of a type, they will be automatically run when freeing or may be directly called using delete foo and must be declared with the following syntax: ~this(...) { ... } static constructors and destructors will be executed the first time that a type is constructed or destructed, and never again. Neither constructors nor destructors are mandatory. All types will initially have a blank destructor as well as a default constructor which takes optional arguments for all fields. Unittest unittest [name] { .. } Unittests are used for executing test code under a unittest build. They function identically to functions besides being automatically run at once and having no return values. Names are not mandatory for unittests, but highly recommended for clarity. unittest foo { ... } Fields and Variables [type] name A field, return value, or parameter are variables, but variables are not a field, return value, or parameter. This distinction is important. Use of void or a user-defined type with no members as the type of a field or variable should be treated as a comptime error, you may get around this through aliasing. All declarations are initialized with zero, this may be prevented by setting the initial value to void . Successive Declaration , name.. Variables of the same type may be successively defined by using , name.. , this allows for tuple assignment to multiple variables. // Variables a, b, and c are all defined as int. int a, b, c; // Variables d, e, and f are all defined as int and have the respective values 1, 2, and 3. int d, e, f = [1, 2, 3]; Bitfields [type] name : [bits] Bitfields are identical to normal variables besides being constrained to a specified bit size. If a type with variables is constrained by a bitfield, all fields must be able to maintain the same ratio of bits as they initially had or it is a comptime error. Despite the deceiving name, bitfields may apply to any variable. struct A { // foo is constrained to 3 bits but acts like a normal field would. T foo : 3; } Attributes [attributes] [arregation] name.. [attributes] [type] name.. Function Exclusive [attributes] [type] name.. [attributes] Attributes are special metadata which may be applied to certain things. They do not necessarily indicate special functionality but may be assigned such. Functions have their attributes after their signature, having attributes prepended the return type will result in the return type having such attributes applied to it. Attribute Definition Applicable public Public accessibility, may be accessed anywhere. All private Private accessibility, may only be accessed by the same declaration it is a part of. All internal Internal accessibility, may only be accessed by the same package as it was declared. All partial May be distributed across several declarations of the given symbol, allows for splitting across multiple files. Types, Modules abstract Does not have an implementation but enforces that, if inherited, it must have an implementation. It is a comptime error to call an abstract function. Function pure Does not modify any state except its parent type (if it has any.) Function system Ignores all safety checks usually applied to functions and may not be called from a safe function, an unsafe function. Function trusted Ignores all safety checks usually applied to functions but may be called from a safe function, manual review. Function safe A safe function with all safety checks, may call trusted and safe . Function @tapped Ignores all attributes that may be inferred or applied to the parent scope(s). Function inline Guarantees that a function is inlined by the compiler or an error is thrown, variables with this will have their allocation inlined. Functions, Variables const Immutable, including by any direct references, does not indicate read-only memory. Variables, Types auto Infers type at comptime, similar to type aliasing but implicit. Variables ref Carries a reference to data. Parameters, Return Values mustuse Must be used or cast to void or an error is thrown. Return Values static Data is stored globally rather than by-instance. Variables atomic Makes data thread-safe through use of atomics. Variables @heap Allocate data on the heap, will result in voidability. Types, Variables @stack Allocate data on the stack. Types, Variables @scalar Allocate data in scalar registers. Types, Variables @floating Allocate data in float registers. Types, Variables @xmmword Allocate data in 128-bit vector registers. Types, Variables @ymmword Allocate data in 256-bit vector registers. Types, Variables @zmmword Allocate data in 512-bit vector registers. Types, Variables @align(n) Aligns data to the given boundary n which must be a power of 2 and supplied. Variables, Types @offset(n) Sets the offset of a field to a specific byte in its parent type, this may change the size of the type and can be used to create unions, n must be supplied. Fields @transient Prevents cache pollution by declaring a variable as non-temporal data. Variables, Types @unroll Hints to the compiler to unroll a loop. Statements Abstract functions must have their signature end in a semicolon without declaring a body. voidable type[?] name Any variable may be voidable by appending ? to the end of the provided type. Declaring a variable as such will result in it being able to evaluate to void , this is indicates that no value has been assigned to it and is fundamentally different from being zeroed, as it exists as a separate state. User-defined Attributes [@][symbol] [aggregation] name.. [@][symbol] [type] name.. User-defined attributes may be created by simply prepending @ before a symbol. Symbols and Aliases A symbol is any literal, statement, or otherwise declaration. Aliases are defined with alias or alias[] (for an array of aliases) to arbitrarily refer to any symbol or value. You may not write to an alias at runtime, as they are evaluated during compilation, but reassignment to an alias at comptime is legal. Aliases may be instance data if assigned to a variable and are able to be used in replacement of any symbol anywhere in code. alias foo = 1; // This function will be evaluated at comptime void bar() pure { // foo now contains a direct alias to bar, this allows us to use foo like it is that symbol. foo = bar; // foo now contains a direct alias to int. foo = int; // Declared a variable with the type of int because it's the symbol stored in foo. foo a = 2; } Generics name[(parameters)] Parameters must be typed as they are normally typed, however, aliases to arbitrary symbols must have the format alias name and type symbols may have the format name where neither alias nor a type is declared. !([arguments]) ![argument] Types and functions may declare generic arguments, these are added as an additional set of parameters inside of parenthesis, and must always evaluate to aliases which makes them comptime exclusive and allow for specialized code-generation. // T acts as an alias to a type. T foo(T)(T a) { return a; } foo!int(1); // or foo!(int)(1); Mixins TBD Statements statement [(arguments)] (varies) Statements are declarations which have special executive functionality, Fern defines the following statements: Statement Definition if Conditionally executes the next line or scope. else Alternate of if in which the next line or scope will be executed if an if was present prior and failed foreach Iterates the next line or scope over a range of values, this may be a data range or integral range by use of L..U where L is the lower bound and U is the upper bound foreach_reverse Identical to foreach but operates in reverse. while Iterates the next line or scope while a condition is true. goto Jumps to a label within code, this is declared as goto name label Labels a part of code to be jumped to by a goto statement, this is declared as name: . with Used to declare a scope in which all function calls are first evaluated as members of a variable. break Exits the current scope. continue Continues to the next iteration in a loop. Statements are not guaranteed to be evaluated at runtime, and may be evaluated at comptime if possible. This behavior may be modified with special compiler attributes.","title":"Grammar"},{"location":"grammar/#grammar","text":"","title":"Grammar"},{"location":"grammar/#module","text":"module name Modules are top level declarations which act like namespaces and may contain lower members inside of it. A module identifier cannot be used more than once unless the module was declared using the partial attribute. A declaration of a module appears as such module name; or partial module name; where name is the name of the module which is being declared.","title":"Module"},{"location":"grammar/#import","text":"import name Import declarations are used to import modules to be used, and may be used anywhere within code, with their effects only applicable in the scope which they were declared. A whole module may be imported with import name; where name is the name of the module being imported, this may include submodules such as in import foo.bar; where the submodule bar in foo is imported, along with all of the submodules of bar . A selection may be imported with import name : foo where name is the name of the module being imported from and foo is the symbol being imported from the module, the same submodule importing rules apply as with whole module imports. A public import may be import even to other modules which import the module in which the public import was declared, this can be done like public import name where name is the name of the module being imported. module foo; public import bar; In this example importing foo would result in also importing bar .","title":"Import"},{"location":"grammar/#types","text":"type is type variable is type Types and variables may be compared to a type using is to evaluate if they are of the same type, this may also be used for comparing a variable to a tagged to see what it contains. Types have a minimum size of 1 byte, but it is a comptime error to use a type with no members to declare a variable. (see Fields and Variables )","title":"Types"},{"location":"grammar/#builtins","text":"The following types are built into Fern, and may be used without any imports: Type Definition Size (b) bool Boolean, false if 0, true otherwise. 1 byte 8-bit signed integer. 1 ubyte 8-bit unsigned integer. 1 short 16-bit signed integer. 2 ushort 16-bit unsigned integer. 2 int 32-bit signed integer. 4 uint 32-bit unsigned integer. 4 long 64-bit signed integer. 8 ulong 64-bit unsigned integer. 8 float 32-bit floating point. 4 double 64-bit floating point. 8 void Represents an untype, may be pointed to but not explicitly declared as a variable. 1 nint Represents the max size signed integer available. variable nuint Represents the max size unsigned integer available. variable char 8-bit character integer. 1 wchar 16-bit character integer. 2 dchar 32-bit character integer. 4 string A string formed out of char variable (array) wstring A string formed out of wchar variable (array) dstring A string formed out of dchar variable (array) Strings are defined as dynamic arrays if their value is not known at comptime, or static arrays if their value is known at comptime (ie: string literals.)","title":"Builtins"},{"location":"grammar/#operators","text":"Operators are a builtin part of the language used to perform certain operations. All of these may be overloaded and functionality varies, but should by default apply by normal rationality. Operator Definition \\|> Conversion pipe operator, used to pipe data to a type, member function, or field. <\\| Downcast operator, downcasts data to its superior type or dereference. > < <= >= Comparison operators, special behavior is defined for array types, which return a mask of where the comparison returned true. == != && \\|\\| , ! Equality and logical operators, with ! and != as NOT operators. [x] [..] [] Slicing and indexing operators, [x] will take the element of the given index, [..] will take the mask or slice of the given range, and [] will get an array as an explicit array type or element-wise array that can have operators performed on it. + - * / % ^^ << >> <<< ^ & \\| ~ Binary operators. ^^ performs exponentiation and ~ is used for range concatenation. -- ++ ~ - Unary postdecrement, postincrement, NOT, and NEG operators. Postdecrement and postincrement may appear as preX versions in which they are after a variable. & Unary pointer reference operator. x if y else z Ternary alternate operator. x..y Iota operator, creates a range from x to y not containing the value y . -> Symbol member operator, which is evaluated at comptime and may evaluate to an alias function operating on a symbol. $ Dollar operator, gets the length of a range, must be overloaded for custom ranges. Unlike other languages you must use the LTR operator <| to dereference. All unary operators are technically RTL, but most have been preserved as they don't have too much of an impact on code readability, * was singled out due to pointer dereferencing being a common operation and & rarely reading RTL in code. The following operators are defined as op-assign, meaning that they perform the operation followed by an assignment. It is highly recommended to use the mask assign operator instead of masking and then assigning when working with masks. Operator += -= *= /= %= ^^= ~= [..]= <<= >>= <<<= ^= &= \\|= [x]=","title":"Operators"},{"location":"grammar/#operator-overloading","text":"Almost all operators may be overloaded in types, this is done by specifying the n-nary of the operator followed by the operator, refer to the following list: Signature Overload nnary read(alias F = void)() . Field or variable reading, optionally takes a field symbol being read, otherwise this is being read. nnary write(alias F = void)() . Field or variable writing, optionally takes a field symbol being written, otherwise this is being written. nnary call(alias F, ARGS...)() . Function calls, taking the symbol of what function is being called. Will not overload UFCS calls! nnary \\|>(S...)() \\|> Conversion pipe, takes the sequence of symbols being piped through. nnary <\\|() <\\| Downcast or dereference. binary <=>(T)(T val) < > <= >= Comparison operators, return 0 for greater, 1 for lesser, 2 for greater or equal, or any other value for lesser or equal. binary ==(T)(T val) == != Equality operators. binary [](T)(T val) [x] Index operator. binary [..](T)(T val) [..] Slice mask operator. binary *(T)(T val) * Multiplication operator. binary /(T)(T val) / Division operator. binary +(T)(T val) + Addition operator. binary -(T)(T val) - Subtraction operator. binary %(T)(T val) % Modulus operator. binary ^^(T)(T val) ^^ Exponentiation operator. binary <<(T)(T val) << SHL operator. binary >>(T)(T val) >> SHL operator. binary <<<(T)(T val) <<< SHL sign preserved operator. binary ^(T)(T val) ^ XOR operator. binary &(T)(T val) & AND operator. binary \\|(T)(T val) \\| OR operator. binary ~(T)(T val) ~ Range concatentation operator. binary &~(T)(T val) & ~ ANDN operator, AND followed by a NOT. unary --() -- Postdecrement and predecrement operator. unary ++() ++ Postincrement and preincrement operator. unary -() - NEG operator. unary $() $ Range length operator. unary !~() ! ~ NOT operators. All operators with a respective assignment operator may have that assignment operator overloaded by appending = before the parameters in the signature, like in binary >>=(T)(T val) .","title":"Operator Overloading"},{"location":"grammar/#arrays","text":"type[] type[length] Fern defines 2 kinds of arrays, static arrays, dynamic arrays. Upon construction, all arrays may use the syntax T[x] to define their length. Dynamic arrays may be created out of any type using the syntax T[] and they store their length and pointer to data as fields length and ptr . Static arrays must have their length known at comptime and may be created out of any type using the syntax T[L] where L is the length of the array. Unlike dynamic arrays, static arrays do not store data by reference, and instead are value-types. However, they still retain comptime data for length and ptr gets a pointer to the data. Static arrays may not be concatenated through use of ~ , however they still must have their length initialized at first. Arrays are cumulative, meaning that you can have arrays of arrays and so on.","title":"Arrays"},{"location":"grammar/#masks","text":"Arrays may be masked, this cannot explicitly be accessed as a type by the user, but can be created using slicing operations and converted back to ranges by way of the [] operator or assignment/conversion to an array type variable.","title":"Masks"},{"location":"grammar/#pointers","text":"type* Pointers are natively sized integers which point to memory, they may be created by using the reference operator & and dereferenced by using the dereference operator * . Pointers may be represented as void* , nint , nuint , or appending * to the end of a type. Pointers share operators with static arrays, meaning they may be sliced, indexed, and so on. Pointers are cumulative, meaning that you can point to pointers and so on.","title":"Pointers"},{"location":"grammar/#user-defined-types","text":"[aggregation] name Fern declares 3 different kinds of user-defined types. A type with no members has a minimum size of 1 byte, however it may also not be explicitly used to declare a variable. Types may be created anonymously, directly inlining their effects by not defining a name, this may not be done using classes as an anonymous nor in a tagged. An example of struct/class syntax is as follows: struct/class Element { int kind; short value; // Anonymous type, acting as a union. tagged { // These occupy the same memory space, with the size being the maximum size used by any type inside of it. int foo; long bar; } } An example of tagged syntax is as follows: tagged IpAddr { ubyte[4] V4; string V6; // This will be the type of the tag, which is uint. // The prime inherit will modify the type of the tag. V819; } All types may, but not must, contain member declarations, and the above are only examples.","title":"User-defined Types"},{"location":"grammar/#tagged","text":"(types..) Tagged have a tag which indicates what kind of value they hold, but they will only ever hold one of their fields as a value. Tagged may be checked for their tag by doing foo is name or foo is type like in foo is V4 . Unlike all other types, tagged may inherit a builtin type as a prime inherit, which will act as the default type for all fields and also the type of the tag , by default the prime inherit will be assumed to be uint . Tagged may be implicitly created by wrapping multiple types in parenthesis, like (int, short) foo and assignment when value is one of int and short . Additionally, tagged may implicitly create from a type by accessing a member, like from IpAddr.V4 in which the default value of V4 is selected. If all members of a tagged are const , they may have a value assigned by default, tag is stripped away (but may still be accessed) and it acts exactly as an enum would in languages like D, Java, or C#. Otherwise default assignment is not allowed. If a tagged is an anonymous type it will not have a tag , and will act as a typical union type would. tagged A : ^ubyte { // This will result in the runtime having to do a lookup if converting 3 to A, because A is not entirely const. const a = 3; int b; } A foo = A.a; A bar = A.b(2); // Illegal! No explicit constructor calls because it is unknown what the tag is supposed to be! A baz = A(2); Fields in tagged act as the constructor as well as data, and tagged may not be directly constructed using the type.","title":"Tagged"},{"location":"grammar/#tuple","text":"[types..] [values..] Tuples may be implicitly created by wrapping multiple types in braces, like [int, short] foo and assignment when value is both of int and short as an array literal. Tuples will usually be weighted above array literals when assigning with the brace syntax to a tuple, otherwise array literals will be weighted above.","title":"Tuple"},{"location":"grammar/#functions","text":"[type] name([(parameters)]) { .. } name([arguments]) return => [variable][value] Functions are executable code with parameters which may be invoked through the syntax name([arguments]) . T foo(...) { ... } Functions that return a type other than void must have a return value. This can be done by using return , which may be used as a variable that will be returned at the end of the function, or as a return statement, which may appear as return; or return => [variable][value]; . Setting or modifying the value of return does not have any effect in a void function, but the return; statement will always lead to an early return.","title":"Functions"},{"location":"grammar/#parameters-and-arguments","text":"","title":"Parameters and Arguments"},{"location":"grammar/#parameters","text":"[variable declaration]... Parameters appended with ... after their declaration will act as variadic, or array parameters which may take an infinite number of said declaration at the end of the list. If a function takes one parameter of an array type, it will be variadic by default, like in this example: void foo(int[2]) { // ... } foo(1, 2); foo([1, 2]); Variadics may appear only once in a signature, and must be the very last declaration, however this rule is slightly bypassed with generics where variadics may appear twice if one of the variadics is used as the type of a runtime argument, like in this example: void foo(A..., B...)(B b) { // ... } // It is impossible to set B explicitly, but this is allowed because it can be set implicitly based on the arguments passed. // A = [int, string] // B = [int, int] foo!(int, string)(1, 2); Parameters with values set after their declaration will have optional values set by default, these, like variadic parameters, must be the last parameters in the function signature.","title":"Parameters"},{"location":"grammar/#arguments","text":"[variable][value]... parameter_name: [variable][value]... Parameters are syntactically an array of variable declarations, and are part of the signature of a declaration. Arguments are the actual values passed to something, like a function, and are either variables or values. You may declare a variable inline as an argument, like foo(int a) which would create a new variable a from the point of that call onwards. Named arguments may be used by using parameter_name: before the value being passed as an argument, where parameter_name is the name of the parameter the argument corresponds to.","title":"Arguments"},{"location":"grammar/#delegates-and-function-pointers","text":"","title":"Delegates and Function Pointers"},{"location":"grammar/#delegate-declaration","text":"[(parameters)] { ... }","title":"Delegate declaration:"},{"location":"grammar/#function-and-delegate-pointer-types","text":"type function([parameters]) type delegate([parameters]) Delegates are scope-independent variable functions which may be passed around and called, they are identical to function pointers in practice, but store context data meaning they are aware of this . You may explicitly create a delegate, but functions and function pointers will also become delegates implicitly.","title":"Function and delegate pointer types:"},{"location":"grammar/#lambdas","text":"[parameters] => .. Lambdas may be declared in function/property syntax or as inline lambdas such as a => return a == 1 where the parameter types are inferred and a delegate is constructed based on the lambda. Use of a lambda for a property will result in the property only having a get . // foo will always return 1. int foo() => 1; // foo is a property that will always return 1. property int foo() => 1;","title":"Lambdas"},{"location":"grammar/#properties","text":"property [type] name { [get { .. }] [set { .. }] Properties are special functions which act as fields, they must have the following declaration syntax, both a get and set are not necessary but you must have one of them. property T foo() { get { ... } set { ... } } This may be accessed in code as such T foo_value = foo or foo = new_foo_value .","title":"Properties"},{"location":"grammar/#constructors-and-destructors","text":"this[(parameters)] { .. } ~this[(parameters)] { .. } Constructors are functions which are used to construct an instance of a type, they are to be called on a type as if the type itself were a function and must be declared with the following syntax: this(...) { ... } Constructors may be called on existing data by use of foo.ctor() in which the overload is chosen by the arguments. Destructors are functions which are used to free an instance of a type, they will be automatically run when freeing or may be directly called using delete foo and must be declared with the following syntax: ~this(...) { ... } static constructors and destructors will be executed the first time that a type is constructed or destructed, and never again. Neither constructors nor destructors are mandatory. All types will initially have a blank destructor as well as a default constructor which takes optional arguments for all fields.","title":"Constructors and Destructors"},{"location":"grammar/#unittest","text":"unittest [name] { .. } Unittests are used for executing test code under a unittest build. They function identically to functions besides being automatically run at once and having no return values. Names are not mandatory for unittests, but highly recommended for clarity. unittest foo { ... }","title":"Unittest"},{"location":"grammar/#fields-and-variables","text":"[type] name A field, return value, or parameter are variables, but variables are not a field, return value, or parameter. This distinction is important. Use of void or a user-defined type with no members as the type of a field or variable should be treated as a comptime error, you may get around this through aliasing. All declarations are initialized with zero, this may be prevented by setting the initial value to void .","title":"Fields and Variables"},{"location":"grammar/#successive-declaration","text":", name.. Variables of the same type may be successively defined by using , name.. , this allows for tuple assignment to multiple variables. // Variables a, b, and c are all defined as int. int a, b, c; // Variables d, e, and f are all defined as int and have the respective values 1, 2, and 3. int d, e, f = [1, 2, 3];","title":"Successive Declaration"},{"location":"grammar/#bitfields","text":"[type] name : [bits] Bitfields are identical to normal variables besides being constrained to a specified bit size. If a type with variables is constrained by a bitfield, all fields must be able to maintain the same ratio of bits as they initially had or it is a comptime error. Despite the deceiving name, bitfields may apply to any variable. struct A { // foo is constrained to 3 bits but acts like a normal field would. T foo : 3; }","title":"Bitfields"},{"location":"grammar/#attributes","text":"[attributes] [arregation] name.. [attributes] [type] name..","title":"Attributes"},{"location":"grammar/#function-exclusive","text":"[attributes] [type] name.. [attributes] Attributes are special metadata which may be applied to certain things. They do not necessarily indicate special functionality but may be assigned such. Functions have their attributes after their signature, having attributes prepended the return type will result in the return type having such attributes applied to it. Attribute Definition Applicable public Public accessibility, may be accessed anywhere. All private Private accessibility, may only be accessed by the same declaration it is a part of. All internal Internal accessibility, may only be accessed by the same package as it was declared. All partial May be distributed across several declarations of the given symbol, allows for splitting across multiple files. Types, Modules abstract Does not have an implementation but enforces that, if inherited, it must have an implementation. It is a comptime error to call an abstract function. Function pure Does not modify any state except its parent type (if it has any.) Function system Ignores all safety checks usually applied to functions and may not be called from a safe function, an unsafe function. Function trusted Ignores all safety checks usually applied to functions but may be called from a safe function, manual review. Function safe A safe function with all safety checks, may call trusted and safe . Function @tapped Ignores all attributes that may be inferred or applied to the parent scope(s). Function inline Guarantees that a function is inlined by the compiler or an error is thrown, variables with this will have their allocation inlined. Functions, Variables const Immutable, including by any direct references, does not indicate read-only memory. Variables, Types auto Infers type at comptime, similar to type aliasing but implicit. Variables ref Carries a reference to data. Parameters, Return Values mustuse Must be used or cast to void or an error is thrown. Return Values static Data is stored globally rather than by-instance. Variables atomic Makes data thread-safe through use of atomics. Variables @heap Allocate data on the heap, will result in voidability. Types, Variables @stack Allocate data on the stack. Types, Variables @scalar Allocate data in scalar registers. Types, Variables @floating Allocate data in float registers. Types, Variables @xmmword Allocate data in 128-bit vector registers. Types, Variables @ymmword Allocate data in 256-bit vector registers. Types, Variables @zmmword Allocate data in 512-bit vector registers. Types, Variables @align(n) Aligns data to the given boundary n which must be a power of 2 and supplied. Variables, Types @offset(n) Sets the offset of a field to a specific byte in its parent type, this may change the size of the type and can be used to create unions, n must be supplied. Fields @transient Prevents cache pollution by declaring a variable as non-temporal data. Variables, Types @unroll Hints to the compiler to unroll a loop. Statements Abstract functions must have their signature end in a semicolon without declaring a body.","title":"Function Exclusive"},{"location":"grammar/#voidable","text":"type[?] name Any variable may be voidable by appending ? to the end of the provided type. Declaring a variable as such will result in it being able to evaluate to void , this is indicates that no value has been assigned to it and is fundamentally different from being zeroed, as it exists as a separate state.","title":"voidable"},{"location":"grammar/#user-defined-attributes","text":"[@][symbol] [aggregation] name.. [@][symbol] [type] name.. User-defined attributes may be created by simply prepending @ before a symbol.","title":"User-defined Attributes"},{"location":"grammar/#symbols-and-aliases","text":"A symbol is any literal, statement, or otherwise declaration. Aliases are defined with alias or alias[] (for an array of aliases) to arbitrarily refer to any symbol or value. You may not write to an alias at runtime, as they are evaluated during compilation, but reassignment to an alias at comptime is legal. Aliases may be instance data if assigned to a variable and are able to be used in replacement of any symbol anywhere in code. alias foo = 1; // This function will be evaluated at comptime void bar() pure { // foo now contains a direct alias to bar, this allows us to use foo like it is that symbol. foo = bar; // foo now contains a direct alias to int. foo = int; // Declared a variable with the type of int because it's the symbol stored in foo. foo a = 2; }","title":"Symbols and Aliases"},{"location":"grammar/#generics","text":"name[(parameters)] Parameters must be typed as they are normally typed, however, aliases to arbitrary symbols must have the format alias name and type symbols may have the format name where neither alias nor a type is declared. !([arguments]) ![argument] Types and functions may declare generic arguments, these are added as an additional set of parameters inside of parenthesis, and must always evaluate to aliases which makes them comptime exclusive and allow for specialized code-generation. // T acts as an alias to a type. T foo(T)(T a) { return a; } foo!int(1); // or foo!(int)(1);","title":"Generics"},{"location":"grammar/#mixins","text":"TBD","title":"Mixins"},{"location":"grammar/#statements","text":"statement [(arguments)] (varies) Statements are declarations which have special executive functionality, Fern defines the following statements: Statement Definition if Conditionally executes the next line or scope. else Alternate of if in which the next line or scope will be executed if an if was present prior and failed foreach Iterates the next line or scope over a range of values, this may be a data range or integral range by use of L..U where L is the lower bound and U is the upper bound foreach_reverse Identical to foreach but operates in reverse. while Iterates the next line or scope while a condition is true. goto Jumps to a label within code, this is declared as goto name label Labels a part of code to be jumped to by a goto statement, this is declared as name: . with Used to declare a scope in which all function calls are first evaluated as members of a variable. break Exits the current scope. continue Continues to the next iteration in a loop. Statements are not guaranteed to be evaluated at runtime, and may be evaluated at comptime if possible. This behavior may be modified with special compiler attributes.","title":"Statements"},{"location":"lexical/","text":"Lexical Strings and Characters String literals may be defined using q{...} or \"...\" , when using the latter syntax d or w may be prepended to dictate the size of the characters ( dchar or wchar ) or r to dictate that all escapes are ignored. Character literals may be defined using '...' in which a single character is defined. Escapes Escape sequences are sequences of characters which result in a special character being used. Sequence Definition \\' ' \\\" \" \\\\ \\ \\0 Null terminator. \\a Alert. \\b Backspace. \\f Form backfeed. \\n Newline. \\r Carriage return. \\t Horizontal tab. \\v Vertical tab. \\xhh.. Hexadecimal character insert. Literals Literal suffixes are suffixes which may be appended to a literal to change the way that the literal is formatted or interpreted. Integral -Fix Definition u Unsigned, suffix. U Signed, suffix. L 64-bit integer, suffix. f 32-bit floating point, suffix. 0x Hexadecimal, prefix. 0X Hexadecimal, prefix. 0o Octal, prefix. 0b Binary, prefix. All integer literals may have their values separated by underscores for clarity, in replacement of commas such as in 10_000 where the literal is the value 10 thousand. Comments, Terminators, and Scopes // comment /* multi-line comment */ Comments in Fern use the syntax \\\\ for single-line and /*..*/ for multi-line. [type] name; [type] name[(parameters)] Terminators in Fern are ; , which are necessary to end any expression or declaration of a signature (such as a type or function.) { .. } Scopes in Fern are started and ended using curly brackets. Keywords Keyword Definition this Refers to the parent instance of the scope in which it was used, it is a comptime error if the scope has no instance. return Return delete Destruct bool Builtin true Builtin false Builtin byte Builtin ubyte Builtin short Builtin ushort Builtin int Builtin uint Builtin long Builtin float Builtin double Builtin ulong Builtin nint Builtin nuint Builtin void Builtin char Builtin wchar Builtin dchar Builtin string Builtin wstring Builtin dstring Builtin pure Attribute const Attribute static Attribute public Attribute private Attribute internal Attribute partial Attribute system Attribute trusted Attribute safe Attribute inline Attribute mustuse Attribute ref Attribute align Attribute offset Attribute atomic Attribute alias Alias module Type import Type struct Type class Type tagged Type unittest Unittest function Function Pointer delegate Function Pointer if Statement else Statement foreach Statement foreach_reverse Statement while Statement goto Statement with Statement break Statement continue Statement mixin Mixin is Conditional debug Versioning export Reserved extern Reserved assert Reserved __asm Reserved Special Symbols The prefix __ is resserved for implementation and thus should be blacklisted for use in declarations. Such implementation are as follows, but implementations may add to this: Symbol Definition __Windows Is Windows being targeted? __Linux Is Linux being targeted? __OSX Is OSX being targeted? __Posix Is Posix being targeted? __iOS Is iOS being targeted? __tvOS Is tvOS being targeted? __watchOS Is watchOS being targeted? __visionOS Is visionOS being targeted? __FreeBSD Is FreeBSD being targeted? __OpenBSD Is OpenBSD being targeted? __NetBSD Is NetBSD being targeted? __Solaris Is Solaris being targeted? __Android Is Android being targeted? __x86 Is x86 being targeted? __x86_64 Is x86_64 being targeted? __x64 Is 64-bit being targeted? __x32 Is 32-bit being targeted? __fnc Is the Fern Native Compiler being used? .sizeof The size in bytes of the symbol being targeted, this is a member. .alignof The alignment in bytes of the symbol being targeted, this is a member. .offsetof The offset in bytes of the symbol being targeted, this is a member. .typeof The type of the symbol being targeted, this is a member. .tag The tag of a tagged, this is a member. .ptr The pointer of an object, this is a member. .length The length of an array, this is a member.","title":"Lexical"},{"location":"lexical/#lexical","text":"","title":"Lexical"},{"location":"lexical/#strings-and-characters","text":"String literals may be defined using q{...} or \"...\" , when using the latter syntax d or w may be prepended to dictate the size of the characters ( dchar or wchar ) or r to dictate that all escapes are ignored. Character literals may be defined using '...' in which a single character is defined.","title":"Strings and Characters"},{"location":"lexical/#escapes","text":"Escape sequences are sequences of characters which result in a special character being used. Sequence Definition \\' ' \\\" \" \\\\ \\ \\0 Null terminator. \\a Alert. \\b Backspace. \\f Form backfeed. \\n Newline. \\r Carriage return. \\t Horizontal tab. \\v Vertical tab. \\xhh.. Hexadecimal character insert.","title":"Escapes"},{"location":"lexical/#literals","text":"Literal suffixes are suffixes which may be appended to a literal to change the way that the literal is formatted or interpreted. Integral -Fix Definition u Unsigned, suffix. U Signed, suffix. L 64-bit integer, suffix. f 32-bit floating point, suffix. 0x Hexadecimal, prefix. 0X Hexadecimal, prefix. 0o Octal, prefix. 0b Binary, prefix. All integer literals may have their values separated by underscores for clarity, in replacement of commas such as in 10_000 where the literal is the value 10 thousand.","title":"Literals"},{"location":"lexical/#comments-terminators-and-scopes","text":"// comment /* multi-line comment */ Comments in Fern use the syntax \\\\ for single-line and /*..*/ for multi-line. [type] name; [type] name[(parameters)] Terminators in Fern are ; , which are necessary to end any expression or declaration of a signature (such as a type or function.) { .. } Scopes in Fern are started and ended using curly brackets.","title":"Comments, Terminators, and Scopes"},{"location":"lexical/#keywords","text":"Keyword Definition this Refers to the parent instance of the scope in which it was used, it is a comptime error if the scope has no instance. return Return delete Destruct bool Builtin true Builtin false Builtin byte Builtin ubyte Builtin short Builtin ushort Builtin int Builtin uint Builtin long Builtin float Builtin double Builtin ulong Builtin nint Builtin nuint Builtin void Builtin char Builtin wchar Builtin dchar Builtin string Builtin wstring Builtin dstring Builtin pure Attribute const Attribute static Attribute public Attribute private Attribute internal Attribute partial Attribute system Attribute trusted Attribute safe Attribute inline Attribute mustuse Attribute ref Attribute align Attribute offset Attribute atomic Attribute alias Alias module Type import Type struct Type class Type tagged Type unittest Unittest function Function Pointer delegate Function Pointer if Statement else Statement foreach Statement foreach_reverse Statement while Statement goto Statement with Statement break Statement continue Statement mixin Mixin is Conditional debug Versioning export Reserved extern Reserved assert Reserved __asm Reserved","title":"Keywords"},{"location":"lexical/#special-symbols","text":"The prefix __ is resserved for implementation and thus should be blacklisted for use in declarations. Such implementation are as follows, but implementations may add to this: Symbol Definition __Windows Is Windows being targeted? __Linux Is Linux being targeted? __OSX Is OSX being targeted? __Posix Is Posix being targeted? __iOS Is iOS being targeted? __tvOS Is tvOS being targeted? __watchOS Is watchOS being targeted? __visionOS Is visionOS being targeted? __FreeBSD Is FreeBSD being targeted? __OpenBSD Is OpenBSD being targeted? __NetBSD Is NetBSD being targeted? __Solaris Is Solaris being targeted? __Android Is Android being targeted? __x86 Is x86 being targeted? __x86_64 Is x86_64 being targeted? __x64 Is 64-bit being targeted? __x32 Is 32-bit being targeted? __fnc Is the Fern Native Compiler being used? .sizeof The size in bytes of the symbol being targeted, this is a member. .alignof The alignment in bytes of the symbol being targeted, this is a member. .offsetof The offset in bytes of the symbol being targeted, this is a member. .typeof The type of the symbol being targeted, this is a member. .tag The tag of a tagged, this is a member. .ptr The pointer of an object, this is a member. .length The length of an array, this is a member.","title":"Special Symbols"},{"location":"metaprogramming/","text":"Metaprogramming Locals are commonly referred to as variables, which in Fern are specifically variables that are local to a function (ie: not a field or parameter variable. ) All symbol structure members may be accessed from any symbol using the -> operator, to see such structures view the section on symbol formats! rt.symbol may be used to access internal symbol structures, but not to directly access full symbol structures at once. auto foo = 1; string bar = \"abc\"; void main() { writeln(foo->size); // 4 writeln(foo->type->identifier); // int writeln(foo->type->name); // int writeln(foo->size == bar->size); // false writeln(bar.length); // 3 writeln(bar->type == string); // true writeln(bar->glob == foo->glob); // true } Symbol Properties Fern has an assortment of utility functions defined for symbols automatically to make working with them more fluid, they may also be defined specially to be used with the -> operator if a comptime available function returns alias and takes in an alias as the first generic parameter. Property Evaluates isType Is this symbol a type? isClass Is this symbol a class? isStruct Is this symbol a struct? isTagged Is this symbol a tagged? isTuple Is this symbol a tuple? isModule Is this symbol a module? isGlob Is this symbol a glob? isAlias Is this symbol an alias? isAliasSeq Is this symbol an alias sequence? isAlias && isArray isFunction Is this symbol a function? isDelegate Is this symbol a delegate? isLambda Is this symbol a lambda? isCtor Is this symbol a constructor? isDtor Is this symbol a destructor? isSCtor Is this symbol a static constructor? isSDtor Is this symbol a static destructor? isUnittest Is this symbol a unittest? isField Is this symbol a field? isLocal Is this symbol a local? isParameter Is this symbol a parameter? isVariable Is this symbol a variable? isField \\|\\| isLocal \\|\\| isParameter isExpression Is this symbol an expression? isLiteral Is this symbol a literal? isArray Is this symbol an array? isDynamicArray Is this symbol a dynamic array? isStaticArray Is this symbol a static array? isAssociativeArray Is this symbol an associative array? isString Is this symbol a string? isWideString Is this symbol a wide string? dstring or wstring isSigned Is this symbol of a signed type? isIntegral Is this symbol an integral? isFloating Is this symbol a floating-point? isNumeric Is this symbol an integral or floating-point? isByRef Is this symbol passed by reference? isRef \\|\\| isClass \\|\\| isKHeap isVector Is this symbol a vector? isKXMM \\|\\| isKYMM \\|\\| isKZMM isPublic Is this symbol publicly visible? isPrivate Is this symbol privately visible? isInternal Is this symbol internally visible? isSafe Is this symbol safe? isSystem Is this symbol system? isTrusted Is this symbol trusted? isStatic Is this symbol static? isGlobal Is this symbol global? isTransient Is this symbol transient? isAtomic Is this symbol atomic? isBitfield Is this symbol a bitfield? This alters the size field of symbols, and thus will result in it being in bits. isPure Is this symbol pure? isConst Is this symbol const? isRef Is this symbol ref? isKHeap Is this symbol a heap kind? isKStack Is this symbol a stack kind? isKScalar Is this symbol a scalar kind? isKFloat Is this symbol a floating-point kind? isKXMM Is this symbol a 128-bit vector kind? isKYMM Is this symbol a 256-bit vector kind? isKZMM Is this symbol a 512-bit vector kind? isKReadOnly Is this symbol a readonly kind? This may, but won't always, happen with const symbols. isKDefault Is this symbol of the default kind? Does not indicate that this was set to default! isNested Is this symbol nested in one or more other non-module symbols? isPrimitive Is this symbol a primitive type? !isAggregate && !isArray isBuiltin Is this symbol not an aggregate? hasDepth Does this symbol have any depth? Pointers and arrays. hasBody Is this symbol a function with instructions? hasDataAllocations Does this symbol have any variables contained within it? isEnum Is this symbol an enum? All members must be const and the type must be a tagged . getOverloads(string) Get all overloads of the given function by name in this symbol. getChild(string) Gets the child of this symbol with the given name. getParent(string) Gets the parent of this symbol with the given name. getAttribute(string) Gets the attribute of this symbol with the given name. getField(string) Gets the field of this symbol with the given name. getFunction(string) Gets the function of this symbol with the given name. getInherit(string) Gets the inherit of this symbol with the given name. getAlias(string) Gets the child alias of this symbol with the given name. hasChild(string) Does this symbol have a child with the given name? hasParent(string) Does this symbol have a parent with the given name? hasAttribute(string) Does this symbol have an attribute with the given name? hasField(string) Does this symbol have a field with the given name? hasFunction(string) Does this symbol have a function with the given name? hasInherit(string) Does this symbol have an inherit with the given name? hasAlias(string) Does this symbol have a child alias with the given name? hasChild(Symbol) Is the given symbol a child of this symbol? hasParent(Symbol) Is the given symbol a parent of this symbol? hasAttribute(Symbol) Is the given symbol an attribute of this symbol? hasField(Symbol) Is the given symbol a field of this symbol? hasFunction(Symbol) Is the given symbol a function of this symbol? hasInherit(Symbol) Does this symbol inherit the given symbol? hasAlias(Symbol) Is the given symbol an alias child of this symbol? Symbol Attributes & Formats Symbol Attribute Definition type Structure of data with or without instance presence - struct , class , tagged or tuple . struct A product-type aggregate passed by-value. class A product-type aggregate passed by-reference. tagged A sum-type aggregate passed by-value with a tag . tuple A sum-type aggregate passed by-value with arbitrary types. module Top or domain level scope with no instance presence. function Executable code scope taking parameters and returning a return type. delegate Dynamic executable code scope taking parameters and returning a return type from an address. lambda Special inline format of delegate . ctor Scope constructor, namely used for type and module . dtor Scope destructor, namely used for type and module . unittest Scope independent executable code taking no parameters and not returning anything. Executes synchronously and may not be called. field Data that exists and persists outside of an execution scope. local Data that exists and persists only inside of an execution scope. parameter Local declarations in a function signature which require arguments. expression Code which may not function without an existing statement to modify, like 1 + 1 literal Value known to the compiler before execution. glob The global scope of the entire program, containing all of its symbols. alias A symbol pointing to another symbol. This is implementation defined, but generally symbols have or store the same information as the following formats internally: Symbol [ Glob glob; SymAttr symattr; string name; Symbol[] parents; Symbol[] children; Symbol[string] attributes; string identifier; Symbol parent; # May not be accessed on primitive types, as there is no module available. Module module; ] Type : Symbol [ Type[string] inherits; Variable[] fields; Function[] functions; ubyte[] data; size_t size; size_t align; # For pointer and arrays, how deeply nested they are. uint depth; string type; ] # This is also used for delegates, lambdas, ctors, dtors, and unittests. Function : Symbol [ Variable[] parameters; # This will include the return and parameters as the first locals. Variable[string] locals; size_t align; Symbol return; string type; ] # This is also used for locals, parameters, expressions, and literals. Variable : Symbol [ Type type; ubyte[] data; size_t size; size_t align; size_t offset; ] Alias : Symbol [ union { Symbol single; Symbol[] many; } // Always \"alias\" string type; ] Module : Symbol [ Symbol[] imports; Type[] types; Variable[] fields; Function[] functions; ] # This is used to store global information about the program. Glob : Symbol [ Symbol[string] symbols; Module[string] modules; Type[string] types; Field[string] fields; Function[string] functions; Alias[string] aliases; Function[] unittests; ]","title":"Metaprogramming"},{"location":"metaprogramming/#metaprogramming","text":"Locals are commonly referred to as variables, which in Fern are specifically variables that are local to a function (ie: not a field or parameter variable. ) All symbol structure members may be accessed from any symbol using the -> operator, to see such structures view the section on symbol formats! rt.symbol may be used to access internal symbol structures, but not to directly access full symbol structures at once. auto foo = 1; string bar = \"abc\"; void main() { writeln(foo->size); // 4 writeln(foo->type->identifier); // int writeln(foo->type->name); // int writeln(foo->size == bar->size); // false writeln(bar.length); // 3 writeln(bar->type == string); // true writeln(bar->glob == foo->glob); // true }","title":"Metaprogramming"},{"location":"metaprogramming/#symbol-properties","text":"Fern has an assortment of utility functions defined for symbols automatically to make working with them more fluid, they may also be defined specially to be used with the -> operator if a comptime available function returns alias and takes in an alias as the first generic parameter. Property Evaluates isType Is this symbol a type? isClass Is this symbol a class? isStruct Is this symbol a struct? isTagged Is this symbol a tagged? isTuple Is this symbol a tuple? isModule Is this symbol a module? isGlob Is this symbol a glob? isAlias Is this symbol an alias? isAliasSeq Is this symbol an alias sequence? isAlias && isArray isFunction Is this symbol a function? isDelegate Is this symbol a delegate? isLambda Is this symbol a lambda? isCtor Is this symbol a constructor? isDtor Is this symbol a destructor? isSCtor Is this symbol a static constructor? isSDtor Is this symbol a static destructor? isUnittest Is this symbol a unittest? isField Is this symbol a field? isLocal Is this symbol a local? isParameter Is this symbol a parameter? isVariable Is this symbol a variable? isField \\|\\| isLocal \\|\\| isParameter isExpression Is this symbol an expression? isLiteral Is this symbol a literal? isArray Is this symbol an array? isDynamicArray Is this symbol a dynamic array? isStaticArray Is this symbol a static array? isAssociativeArray Is this symbol an associative array? isString Is this symbol a string? isWideString Is this symbol a wide string? dstring or wstring isSigned Is this symbol of a signed type? isIntegral Is this symbol an integral? isFloating Is this symbol a floating-point? isNumeric Is this symbol an integral or floating-point? isByRef Is this symbol passed by reference? isRef \\|\\| isClass \\|\\| isKHeap isVector Is this symbol a vector? isKXMM \\|\\| isKYMM \\|\\| isKZMM isPublic Is this symbol publicly visible? isPrivate Is this symbol privately visible? isInternal Is this symbol internally visible? isSafe Is this symbol safe? isSystem Is this symbol system? isTrusted Is this symbol trusted? isStatic Is this symbol static? isGlobal Is this symbol global? isTransient Is this symbol transient? isAtomic Is this symbol atomic? isBitfield Is this symbol a bitfield? This alters the size field of symbols, and thus will result in it being in bits. isPure Is this symbol pure? isConst Is this symbol const? isRef Is this symbol ref? isKHeap Is this symbol a heap kind? isKStack Is this symbol a stack kind? isKScalar Is this symbol a scalar kind? isKFloat Is this symbol a floating-point kind? isKXMM Is this symbol a 128-bit vector kind? isKYMM Is this symbol a 256-bit vector kind? isKZMM Is this symbol a 512-bit vector kind? isKReadOnly Is this symbol a readonly kind? This may, but won't always, happen with const symbols. isKDefault Is this symbol of the default kind? Does not indicate that this was set to default! isNested Is this symbol nested in one or more other non-module symbols? isPrimitive Is this symbol a primitive type? !isAggregate && !isArray isBuiltin Is this symbol not an aggregate? hasDepth Does this symbol have any depth? Pointers and arrays. hasBody Is this symbol a function with instructions? hasDataAllocations Does this symbol have any variables contained within it? isEnum Is this symbol an enum? All members must be const and the type must be a tagged . getOverloads(string) Get all overloads of the given function by name in this symbol. getChild(string) Gets the child of this symbol with the given name. getParent(string) Gets the parent of this symbol with the given name. getAttribute(string) Gets the attribute of this symbol with the given name. getField(string) Gets the field of this symbol with the given name. getFunction(string) Gets the function of this symbol with the given name. getInherit(string) Gets the inherit of this symbol with the given name. getAlias(string) Gets the child alias of this symbol with the given name. hasChild(string) Does this symbol have a child with the given name? hasParent(string) Does this symbol have a parent with the given name? hasAttribute(string) Does this symbol have an attribute with the given name? hasField(string) Does this symbol have a field with the given name? hasFunction(string) Does this symbol have a function with the given name? hasInherit(string) Does this symbol have an inherit with the given name? hasAlias(string) Does this symbol have a child alias with the given name? hasChild(Symbol) Is the given symbol a child of this symbol? hasParent(Symbol) Is the given symbol a parent of this symbol? hasAttribute(Symbol) Is the given symbol an attribute of this symbol? hasField(Symbol) Is the given symbol a field of this symbol? hasFunction(Symbol) Is the given symbol a function of this symbol? hasInherit(Symbol) Does this symbol inherit the given symbol? hasAlias(Symbol) Is the given symbol an alias child of this symbol?","title":"Symbol Properties"},{"location":"metaprogramming/#symbol-attributes-formats","text":"Symbol Attribute Definition type Structure of data with or without instance presence - struct , class , tagged or tuple . struct A product-type aggregate passed by-value. class A product-type aggregate passed by-reference. tagged A sum-type aggregate passed by-value with a tag . tuple A sum-type aggregate passed by-value with arbitrary types. module Top or domain level scope with no instance presence. function Executable code scope taking parameters and returning a return type. delegate Dynamic executable code scope taking parameters and returning a return type from an address. lambda Special inline format of delegate . ctor Scope constructor, namely used for type and module . dtor Scope destructor, namely used for type and module . unittest Scope independent executable code taking no parameters and not returning anything. Executes synchronously and may not be called. field Data that exists and persists outside of an execution scope. local Data that exists and persists only inside of an execution scope. parameter Local declarations in a function signature which require arguments. expression Code which may not function without an existing statement to modify, like 1 + 1 literal Value known to the compiler before execution. glob The global scope of the entire program, containing all of its symbols. alias A symbol pointing to another symbol. This is implementation defined, but generally symbols have or store the same information as the following formats internally: Symbol [ Glob glob; SymAttr symattr; string name; Symbol[] parents; Symbol[] children; Symbol[string] attributes; string identifier; Symbol parent; # May not be accessed on primitive types, as there is no module available. Module module; ] Type : Symbol [ Type[string] inherits; Variable[] fields; Function[] functions; ubyte[] data; size_t size; size_t align; # For pointer and arrays, how deeply nested they are. uint depth; string type; ] # This is also used for delegates, lambdas, ctors, dtors, and unittests. Function : Symbol [ Variable[] parameters; # This will include the return and parameters as the first locals. Variable[string] locals; size_t align; Symbol return; string type; ] # This is also used for locals, parameters, expressions, and literals. Variable : Symbol [ Type type; ubyte[] data; size_t size; size_t align; size_t offset; ] Alias : Symbol [ union { Symbol single; Symbol[] many; } // Always \"alias\" string type; ] Module : Symbol [ Symbol[] imports; Type[] types; Variable[] fields; Function[] functions; ] # This is used to store global information about the program. Glob : Symbol [ Symbol[string] symbols; Module[string] modules; Type[string] types; Field[string] fields; Function[string] functions; Alias[string] aliases; Function[] unittests; ]","title":"Symbol Attributes &amp; Formats"},{"location":"model/","text":"Model Fern is symbol-oriented, meaning that no matter what you're doing, it prioritizes symbols and guaranteeing semantics over strong-typing and data storage. This is intended to be without compromise, errors will be thrown if Fern cannot determine how to make your code function, but also the backend may implicitly do things without your knowledge if it means compilation. Versioning and Contracts Versioning may be done by using static if to influence code generation alongside compilation symbols . The debug keyword is provided to selectively compile a line or scope if targeting debug build. Memory Management Fern uses hybrid LRC and GC memory management. This means Fern will default to linear reference counting, counting the references to variables in the current hierarchy until references reach zero and free is inserted into the code to release the variable. Upon failure a garbage collector will be defaulted to, incrementing an internal counter which will indicate the number of living GC-controlled objects, the garbage collector will periodically run (deterministic but this is not to be exposed) and will not do any collections or marking unless the counter of living objects is above zero. Information on LRC is highly implementation dependent, but expected behavior can be found in phases . The garbage collector is also implementation dependent, but expected behavior is as follows: All allocations add comptime metadata about the types being allocated and any pointers they contain at what offsets. 1. A living objects counter is incremented in the GC. 2. GC checkpoint is inserted in the last function call of a function which allocated a GC object, this will result in the GC running at the start of said function. 3. The GC will run if the living objects counter is greater than zero, which will start by halting all threads. 4. While all threads are halted the stack will be scanned checking for all pointers of any kind, all found pointers are added to a list, and then threads are resumed. 5. The heap is scanned, checking all pointer offsets in allocated regions, all found pointers are added to a list. 6. Any region not pointed to by any pointer in the list are freed and the living objects counter is decremented by the number of freed regions and set to a minimum of 0. Inheritance name [: [^]inherits..] Inheritance allows for code to be easier reused across your codebase and more consistent, clear distribution of members and data across inheriting symbols. The downcasting ( <| ) operator helps facilitate moving to inherited types. Where are interfaces? Fret not child, they exist no more, use abstract functions to achieve such lofty goals. Function Inheritance Functions may inherit from another function, this simply causes the function to act as another function but with localized attributes. Return value and parameters must match up with the inherited function. int foo(long a) => a |> int; // bar inherits all of the code from foo, meaning that it functions the exact same, but we can change the attributes. int bar(long a) pure : foo; // This is illegal, baz may not inherit from foo because it has a different return value. void baz(long a) : foo; Type Inheritance Types may inherit from other types, causing all members to be inherited. If the inheriting type has a member identical to an inherited type, the inheritance of that member will be ignored (retaining only one.) An inherited type must have at least one member to inherit, not have any non-abstract member collisions, and not be a builtin, array, pointer, or tagged, or a comptime error is thrown. Abstract functions contained within an inherited type must be implemented by the inheriting type or a comptime error will be thrown, this is done by defining the member and giving it a body. A type may inherit a single prime ( ^ ) type prepended before the inherited type name, this will result in all operators to be inherited, which is disabled by default. struct A { int a; abstract int foo(); } struct B { long b; } // C inherits all members of A and B, with A being the prime inherit and thus technically the operators of A are inherited, but we don't have any. struct C : ^A, B { // We must declare a body for foo, as it is an abstract and requires an implementation; int foo() => 1337; } Casts and Conversions Casts in Fern are largely implicit, and need not an operator, however, the |> is used for conversion and may also perform casting or conversion piping. All casts and conversions will recursively try to cast members, but will not try to convert. An comptime error will be thrown if it is impossible to cast from one type to another or to convert from one type to another. Conversion Pipe variable |> type[.member] Conversion piping is used to pipe data to a type's member. It may also be used to normally convert data to a type if no member is specified. Piping to a member will result in the data first being cast or converted to the type in order to access the member. Downcast variable <| type <| Downcasting casts a variable to its superior type or retrieves the symbol of a type's superior type. Reinterpret Cast Reinterpreting is a direct cast from one type to another, where no bits are lost or gained and field layout is retained across the cast. Static arrays may reinterpret to any type, so long as no bits are lost or gained. struct A { int a; byte b; } struct B { int a; byte b; } // B is implicitly reinterpreted as A, since they have the same field layout A foo = B(1, 2); Pointer Cast Pointer casting is a direct cast from one pointer to another where element types between the two pointers are able to cast or the type being cast to is void* , nint , or nuint . struct A { int a; } A foo; // A* is being cast to int* because A may cast to int. int* bar = &foo; // int* is being cast to void* because all pointers may cast to void* void* baz = bar; // void* is being cast to nuint because all pointers may cast to nuint. nuint foo2 = baz; Stranded Cast Stranded casting is a form of reinterpret cast in which a structure with a single field may cast to the type of that single field. struct A { int a; } // foo is now the value of `A.a` because it is a stranded field. int foo = A(); Promotion Cast Integers may promote to a larger integer in which they do not lose any bits and maintain the same format. As float and double do not maintain the same format, float cannot be promoted to double . int foo = 1; // foo is promoted to long. long bar = foo; Reorder Conversion Reordering is a conversion from one type to another, where no bits are lost or gained but field layout is not retained across the conversion. struct A { byte a; int b; } struct B { int a; byte b; } // B is implicitly reordered to A, since the field layout needs only reordered. A foo = B(1, 2); Fulfillment Conversion Fulfillment is a conversion in which as many fields as possible are transfered from one type to another. It is a comptime error for none of the fields in either type to be fulfilled. struct A { int a; short b; long c; } struct B { int a; byte b; } // The fields a and b from B are fulfilled in A as well as possible, meaning now the value of a and b in A are the same as they were in B, and c becomes zeroed. A foo = B(1, 2) |> A; Array Conversion This conversion only is necessary when converting to an array type, casting from happens implicitly. Array conversion is a conversion in which the length field of the array is the only thing modified, as it adjusts to the correct size based on the element. long[] foo = [1L]; // long[] is converted to a byte[8], bounds checking determines if this is safe. byte[8] bar = foo |> byte[8]; // byte[8] is converted to a long[], with the length automatically determined to be 1. long[] foo = bar |> long[]; Promotion II and Integral Conversion Integrals may freely convert to each other, where converting a floating point to an integer will result in rounding up from .5 to the nearest whole number. This also permits arbitrary pointer conversion to and from any pointer or integer type. Promotion also may happen from float to double and other integrals which do not maintain the same format or have data loss. float foo = 2.3; // bar will be 2, as it is rounded down from `.5`. int bar = foo |> int; // This is very bad but legal. void* foo2 = bar |> void*; // foo2 is actually cast from void* to int*. int* bar2 = foo2 |> int*; Demotion Conversion Integrals may demote from one to another, where bits are lost and format is irrelevant. long foo = 1; /// 32 bits are lost, in this conversion. int bar = foo |> int; UFCS CTFE ABI","title":"Model"},{"location":"model/#model","text":"Fern is symbol-oriented, meaning that no matter what you're doing, it prioritizes symbols and guaranteeing semantics over strong-typing and data storage. This is intended to be without compromise, errors will be thrown if Fern cannot determine how to make your code function, but also the backend may implicitly do things without your knowledge if it means compilation.","title":"Model"},{"location":"model/#versioning-and-contracts","text":"Versioning may be done by using static if to influence code generation alongside compilation symbols . The debug keyword is provided to selectively compile a line or scope if targeting debug build.","title":"Versioning and Contracts"},{"location":"model/#memory-management","text":"Fern uses hybrid LRC and GC memory management. This means Fern will default to linear reference counting, counting the references to variables in the current hierarchy until references reach zero and free is inserted into the code to release the variable. Upon failure a garbage collector will be defaulted to, incrementing an internal counter which will indicate the number of living GC-controlled objects, the garbage collector will periodically run (deterministic but this is not to be exposed) and will not do any collections or marking unless the counter of living objects is above zero. Information on LRC is highly implementation dependent, but expected behavior can be found in phases . The garbage collector is also implementation dependent, but expected behavior is as follows: All allocations add comptime metadata about the types being allocated and any pointers they contain at what offsets. 1. A living objects counter is incremented in the GC. 2. GC checkpoint is inserted in the last function call of a function which allocated a GC object, this will result in the GC running at the start of said function. 3. The GC will run if the living objects counter is greater than zero, which will start by halting all threads. 4. While all threads are halted the stack will be scanned checking for all pointers of any kind, all found pointers are added to a list, and then threads are resumed. 5. The heap is scanned, checking all pointer offsets in allocated regions, all found pointers are added to a list. 6. Any region not pointed to by any pointer in the list are freed and the living objects counter is decremented by the number of freed regions and set to a minimum of 0.","title":"Memory Management"},{"location":"model/#inheritance","text":"name [: [^]inherits..] Inheritance allows for code to be easier reused across your codebase and more consistent, clear distribution of members and data across inheriting symbols. The downcasting ( <| ) operator helps facilitate moving to inherited types. Where are interfaces? Fret not child, they exist no more, use abstract functions to achieve such lofty goals.","title":"Inheritance"},{"location":"model/#function-inheritance","text":"Functions may inherit from another function, this simply causes the function to act as another function but with localized attributes. Return value and parameters must match up with the inherited function. int foo(long a) => a |> int; // bar inherits all of the code from foo, meaning that it functions the exact same, but we can change the attributes. int bar(long a) pure : foo; // This is illegal, baz may not inherit from foo because it has a different return value. void baz(long a) : foo;","title":"Function Inheritance"},{"location":"model/#type-inheritance","text":"Types may inherit from other types, causing all members to be inherited. If the inheriting type has a member identical to an inherited type, the inheritance of that member will be ignored (retaining only one.) An inherited type must have at least one member to inherit, not have any non-abstract member collisions, and not be a builtin, array, pointer, or tagged, or a comptime error is thrown. Abstract functions contained within an inherited type must be implemented by the inheriting type or a comptime error will be thrown, this is done by defining the member and giving it a body. A type may inherit a single prime ( ^ ) type prepended before the inherited type name, this will result in all operators to be inherited, which is disabled by default. struct A { int a; abstract int foo(); } struct B { long b; } // C inherits all members of A and B, with A being the prime inherit and thus technically the operators of A are inherited, but we don't have any. struct C : ^A, B { // We must declare a body for foo, as it is an abstract and requires an implementation; int foo() => 1337; }","title":"Type Inheritance"},{"location":"model/#casts-and-conversions","text":"Casts in Fern are largely implicit, and need not an operator, however, the |> is used for conversion and may also perform casting or conversion piping. All casts and conversions will recursively try to cast members, but will not try to convert. An comptime error will be thrown if it is impossible to cast from one type to another or to convert from one type to another.","title":"Casts and Conversions"},{"location":"model/#conversion-pipe","text":"variable |> type[.member] Conversion piping is used to pipe data to a type's member. It may also be used to normally convert data to a type if no member is specified. Piping to a member will result in the data first being cast or converted to the type in order to access the member.","title":"Conversion Pipe"},{"location":"model/#downcast","text":"variable <| type <| Downcasting casts a variable to its superior type or retrieves the symbol of a type's superior type.","title":"Downcast"},{"location":"model/#reinterpret-cast","text":"Reinterpreting is a direct cast from one type to another, where no bits are lost or gained and field layout is retained across the cast. Static arrays may reinterpret to any type, so long as no bits are lost or gained. struct A { int a; byte b; } struct B { int a; byte b; } // B is implicitly reinterpreted as A, since they have the same field layout A foo = B(1, 2);","title":"Reinterpret Cast"},{"location":"model/#pointer-cast","text":"Pointer casting is a direct cast from one pointer to another where element types between the two pointers are able to cast or the type being cast to is void* , nint , or nuint . struct A { int a; } A foo; // A* is being cast to int* because A may cast to int. int* bar = &foo; // int* is being cast to void* because all pointers may cast to void* void* baz = bar; // void* is being cast to nuint because all pointers may cast to nuint. nuint foo2 = baz;","title":"Pointer Cast"},{"location":"model/#stranded-cast","text":"Stranded casting is a form of reinterpret cast in which a structure with a single field may cast to the type of that single field. struct A { int a; } // foo is now the value of `A.a` because it is a stranded field. int foo = A();","title":"Stranded Cast"},{"location":"model/#promotion-cast","text":"Integers may promote to a larger integer in which they do not lose any bits and maintain the same format. As float and double do not maintain the same format, float cannot be promoted to double . int foo = 1; // foo is promoted to long. long bar = foo;","title":"Promotion Cast"},{"location":"model/#reorder-conversion","text":"Reordering is a conversion from one type to another, where no bits are lost or gained but field layout is not retained across the conversion. struct A { byte a; int b; } struct B { int a; byte b; } // B is implicitly reordered to A, since the field layout needs only reordered. A foo = B(1, 2);","title":"Reorder Conversion"},{"location":"model/#fulfillment-conversion","text":"Fulfillment is a conversion in which as many fields as possible are transfered from one type to another. It is a comptime error for none of the fields in either type to be fulfilled. struct A { int a; short b; long c; } struct B { int a; byte b; } // The fields a and b from B are fulfilled in A as well as possible, meaning now the value of a and b in A are the same as they were in B, and c becomes zeroed. A foo = B(1, 2) |> A;","title":"Fulfillment Conversion"},{"location":"model/#array-conversion","text":"This conversion only is necessary when converting to an array type, casting from happens implicitly. Array conversion is a conversion in which the length field of the array is the only thing modified, as it adjusts to the correct size based on the element. long[] foo = [1L]; // long[] is converted to a byte[8], bounds checking determines if this is safe. byte[8] bar = foo |> byte[8]; // byte[8] is converted to a long[], with the length automatically determined to be 1. long[] foo = bar |> long[];","title":"Array Conversion"},{"location":"model/#promotion-ii-and-integral-conversion","text":"Integrals may freely convert to each other, where converting a floating point to an integer will result in rounding up from .5 to the nearest whole number. This also permits arbitrary pointer conversion to and from any pointer or integer type. Promotion also may happen from float to double and other integrals which do not maintain the same format or have data loss. float foo = 2.3; // bar will be 2, as it is rounded down from `.5`. int bar = foo |> int; // This is very bad but legal. void* foo2 = bar |> void*; // foo2 is actually cast from void* to int*. int* bar2 = foo2 |> int*;","title":"Promotion II and Integral Conversion"},{"location":"model/#demotion-conversion","text":"Integrals may demote from one to another, where bits are lost and format is irrelevant. long foo = 1; /// 32 bits are lost, in this conversion. int bar = foo |> int;","title":"Demotion Conversion"},{"location":"model/#ufcs","text":"","title":"UFCS"},{"location":"model/#ctfe","text":"","title":"CTFE"},{"location":"model/#abi","text":"","title":"ABI"}]}